/* automatically generated by rust-bindgen 0.63.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const REQUEST_HOST_TO_DEVICE: u32 = 0;
pub const REQUEST_DEVICE_TO_HOST: u32 = 1;
pub const REQUEST_STANDARD: u32 = 0;
pub const REQUEST_CLASS: u32 = 1;
pub const REQUEST_VENDOR: u32 = 2;
pub const REQUEST_RESERVED: u32 = 3;
pub const REQUEST_TO_DEVICE: u32 = 0;
pub const REQUEST_TO_INTERFACE: u32 = 1;
pub const REQUEST_TO_ENDPOINT: u32 = 2;
pub const REQUEST_TO_OTHER: u32 = 3;
pub const USB_REQUEST_GET_STATUS: u32 = 0;
pub const USB_REQUEST_CLEAR_FEATURE: u32 = 1;
pub const USB_REQUEST_SET_FEATURE: u32 = 3;
pub const USB_REQUEST_SET_ADDRESS: u32 = 5;
pub const USB_REQUEST_GET_DESCRIPTOR: u32 = 6;
pub const USB_REQUEST_SET_DESCRIPTOR: u32 = 7;
pub const USB_REQUEST_GET_CONFIGURATION: u32 = 8;
pub const USB_REQUEST_SET_CONFIGURATION: u32 = 9;
pub const USB_REQUEST_GET_INTERFACE: u32 = 10;
pub const USB_REQUEST_SET_INTERFACE: u32 = 11;
pub const USB_REQUEST_SYNC_FRAME: u32 = 12;
pub const USB_GETSTATUS_SELF_POWERED: u32 = 1;
pub const USB_GETSTATUS_REMOTE_WAKEUP: u32 = 2;
pub const USB_GETSTATUS_ENDPOINT_STALL: u32 = 1;
pub const USB_FEATURE_ENDPOINT_STALL: u32 = 0;
pub const USB_FEATURE_REMOTE_WAKEUP: u32 = 1;
pub const USB_FEATURE_TEST_MODE: u32 = 2;
pub const USB_DEVICE_DESCRIPTOR_TYPE: u32 = 1;
pub const USB_CONFIGURATION_DESCRIPTOR_TYPE: u32 = 2;
pub const USB_STRING_DESCRIPTOR_TYPE: u32 = 3;
pub const USB_INTERFACE_DESCRIPTOR_TYPE: u32 = 4;
pub const USB_ENDPOINT_DESCRIPTOR_TYPE: u32 = 5;
pub const USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE: u32 = 6;
pub const USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE: u32 = 7;
pub const USB_INTERFACE_POWER_DESCRIPTOR_TYPE: u32 = 8;
pub const USB_OTG_DESCRIPTOR_TYPE: u32 = 9;
pub const USB_DEBUG_DESCRIPTOR_TYPE: u32 = 10;
pub const USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE: u32 = 11;
pub const USB_DEVICE_CLASS_RESERVED: u32 = 0;
pub const USB_DEVICE_CLASS_AUDIO: u32 = 1;
pub const USB_DEVICE_CLASS_COMMUNICATIONS: u32 = 2;
pub const USB_DEVICE_CLASS_HUMAN_INTERFACE: u32 = 3;
pub const USB_DEVICE_CLASS_MONITOR: u32 = 4;
pub const USB_DEVICE_CLASS_PHYSICAL_INTERFACE: u32 = 5;
pub const USB_DEVICE_CLASS_POWER: u32 = 6;
pub const USB_DEVICE_CLASS_PRINTER: u32 = 7;
pub const USB_DEVICE_CLASS_STORAGE: u32 = 8;
pub const USB_DEVICE_CLASS_HUB: u32 = 9;
pub const USB_DEVICE_CLASS_MISCELLANEOUS: u32 = 239;
pub const USB_DEVICE_CLASS_APP: u32 = 254;
pub const USB_DEVICE_CLASS_VENDOR_SPECIFIC: u32 = 255;
pub const USB_CONFIG_POWERED_MASK: u32 = 64;
pub const USB_CONFIG_BUS_POWERED: u32 = 128;
pub const USB_CONFIG_SELF_POWERED: u32 = 192;
pub const USB_CONFIG_REMOTE_WAKEUP: u32 = 32;
pub const USB_ENDPOINT_DIRECTION_MASK: u32 = 128;
pub const USB_ENDPOINT_TYPE_MASK: u32 = 3;
pub const USB_ENDPOINT_TYPE_CONTROL: u32 = 0;
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS: u32 = 1;
pub const USB_ENDPOINT_TYPE_BULK: u32 = 2;
pub const USB_ENDPOINT_TYPE_INTERRUPT: u32 = 3;
pub const USB_ENDPOINT_SYNC_MASK: u32 = 12;
pub const USB_ENDPOINT_SYNC_NO_SYNCHRONIZATION: u32 = 0;
pub const USB_ENDPOINT_SYNC_ASYNCHRONOUS: u32 = 4;
pub const USB_ENDPOINT_SYNC_ADAPTIVE: u32 = 8;
pub const USB_ENDPOINT_SYNC_SYNCHRONOUS: u32 = 12;
pub const USB_ENDPOINT_USAGE_MASK: u32 = 48;
pub const USB_ENDPOINT_USAGE_DATA: u32 = 0;
pub const USB_ENDPOINT_USAGE_FEEDBACK: u32 = 16;
pub const USB_ENDPOINT_USAGE_IMPLICIT_FEEDBACK: u32 = 32;
pub const USB_ENDPOINT_USAGE_RESERVED: u32 = 48;
pub const USB_ENDPOINT_0_HS_MAXP: u32 = 64;
pub const USB_ENDPOINT_0_LS_MAXP: u32 = 8;
pub const USB_ENDPOINT_BULK_HS_MAXP: u32 = 512;
pub const MSC_SUBCLASS_RBC: u32 = 1;
pub const MSC_SUBCLASS_SFF8020I_MMC2: u32 = 2;
pub const MSC_SUBCLASS_QIC157: u32 = 3;
pub const MSC_SUBCLASS_UFI: u32 = 4;
pub const MSC_SUBCLASS_SFF8070I: u32 = 5;
pub const MSC_SUBCLASS_SCSI: u32 = 6;
pub const MSC_PROTOCOL_CBI_INT: u32 = 0;
pub const MSC_PROTOCOL_CBI_NOINT: u32 = 1;
pub const MSC_PROTOCOL_BULK_ONLY: u32 = 80;
pub const MSC_REQUEST_RESET: u32 = 255;
pub const MSC_REQUEST_GET_MAX_LUN: u32 = 254;
pub const MSC_BS_CBW: u32 = 0;
pub const MSC_BS_DATA_OUT: u32 = 1;
pub const MSC_BS_DATA_IN: u32 = 2;
pub const MSC_BS_DATA_IN_LAST: u32 = 3;
pub const MSC_BS_DATA_IN_LAST_STALL: u32 = 4;
pub const MSC_BS_CSW: u32 = 5;
pub const MSC_BS_ERROR: u32 = 6;
pub const MSC_CBW_Signature: u32 = 1128420181;
pub const MSC_CSW_Signature: u32 = 1396855637;
pub const CSW_CMD_PASSED: u32 = 0;
pub const CSW_CMD_FAILED: u32 = 1;
pub const CSW_PHASE_ERROR: u32 = 2;
pub const SCSI_TEST_UNIT_READY: u32 = 0;
pub const SCSI_REQUEST_SENSE: u32 = 3;
pub const SCSI_FORMAT_UNIT: u32 = 4;
pub const SCSI_INQUIRY: u32 = 18;
pub const SCSI_MODE_SELECT6: u32 = 21;
pub const SCSI_MODE_SENSE6: u32 = 26;
pub const SCSI_START_STOP_UNIT: u32 = 27;
pub const SCSI_MEDIA_REMOVAL: u32 = 30;
pub const SCSI_READ_FORMAT_CAPACITIES: u32 = 35;
pub const SCSI_READ_CAPACITY: u32 = 37;
pub const SCSI_READ10: u32 = 40;
pub const SCSI_WRITE10: u32 = 42;
pub const SCSI_VERIFY10: u32 = 47;
pub const SCSI_READ12: u32 = 168;
pub const SCSI_WRITE12: u32 = 170;
pub const SCSI_MODE_SELECT10: u32 = 85;
pub const SCSI_MODE_SENSE10: u32 = 90;
pub const USB_DFU_IF_NUM: u32 = 0;
pub const USB_DFU_DESCRIPTOR_TYPE: u32 = 33;
pub const USB_DFU_DESCRIPTOR_SIZE: u32 = 9;
pub const USB_DFU_SUBCLASS: u32 = 1;
pub const USB_REQ_DFU_DETACH: u32 = 0;
pub const USB_REQ_DFU_DNLOAD: u32 = 1;
pub const USB_REQ_DFU_UPLOAD: u32 = 2;
pub const USB_REQ_DFU_GETSTATUS: u32 = 3;
pub const USB_REQ_DFU_CLRSTATUS: u32 = 4;
pub const USB_REQ_DFU_GETSTATE: u32 = 5;
pub const USB_REQ_DFU_ABORT: u32 = 6;
pub const DFU_STATUS_OK: u32 = 0;
pub const DFU_STATUS_errTARGET: u32 = 1;
pub const DFU_STATUS_errFILE: u32 = 2;
pub const DFU_STATUS_errWRITE: u32 = 3;
pub const DFU_STATUS_errERASE: u32 = 4;
pub const DFU_STATUS_errCHECK_ERASED: u32 = 5;
pub const DFU_STATUS_errPROG: u32 = 6;
pub const DFU_STATUS_errVERIFY: u32 = 7;
pub const DFU_STATUS_errADDRESS: u32 = 8;
pub const DFU_STATUS_errNOTDONE: u32 = 9;
pub const DFU_STATUS_errFIRMWARE: u32 = 10;
pub const DFU_STATUS_errVENDOR: u32 = 11;
pub const DFU_STATUS_errUSBR: u32 = 12;
pub const DFU_STATUS_errPOR: u32 = 13;
pub const DFU_STATUS_errUNKNOWN: u32 = 14;
pub const DFU_STATUS_errSTALLEDPKT: u32 = 15;
pub const DFU_EP0_NONE: u32 = 0;
pub const DFU_EP0_UNHANDLED: u32 = 1;
pub const DFU_EP0_STALL: u32 = 2;
pub const DFU_EP0_ZLP: u32 = 3;
pub const DFU_EP0_DATA: u32 = 4;
pub const USB_DFU_CAN_DOWNLOAD: u32 = 1;
pub const USB_DFU_CAN_UPLOAD: u32 = 2;
pub const USB_DFU_MANIFEST_TOL: u32 = 4;
pub const USB_DFU_WILL_DETACH: u32 = 8;
pub const DFU_GET_STATUS_SIZE: u32 = 6;
pub const HID_SUBCLASS_NONE: u32 = 0;
pub const HID_SUBCLASS_BOOT: u32 = 1;
pub const HID_PROTOCOL_NONE: u32 = 0;
pub const HID_PROTOCOL_KEYBOARD: u32 = 1;
pub const HID_PROTOCOL_MOUSE: u32 = 2;
pub const HID_HID_DESCRIPTOR_TYPE: u32 = 33;
pub const HID_REPORT_DESCRIPTOR_TYPE: u32 = 34;
pub const HID_PHYSICAL_DESCRIPTOR_TYPE: u32 = 35;
pub const HID_REQUEST_GET_REPORT: u32 = 1;
pub const HID_REQUEST_GET_IDLE: u32 = 2;
pub const HID_REQUEST_GET_PROTOCOL: u32 = 3;
pub const HID_REQUEST_SET_REPORT: u32 = 9;
pub const HID_REQUEST_SET_IDLE: u32 = 10;
pub const HID_REQUEST_SET_PROTOCOL: u32 = 11;
pub const HID_REPORT_INPUT: u32 = 1;
pub const HID_REPORT_OUTPUT: u32 = 2;
pub const HID_REPORT_FEATURE: u32 = 3;
pub const HID_USAGE_PAGE_UNDEFINED: u32 = 0;
pub const HID_USAGE_PAGE_GENERIC: u32 = 1;
pub const HID_USAGE_PAGE_SIMULATION: u32 = 2;
pub const HID_USAGE_PAGE_VR: u32 = 3;
pub const HID_USAGE_PAGE_SPORT: u32 = 4;
pub const HID_USAGE_PAGE_GAME: u32 = 5;
pub const HID_USAGE_PAGE_DEV_CONTROLS: u32 = 6;
pub const HID_USAGE_PAGE_KEYBOARD: u32 = 7;
pub const HID_USAGE_PAGE_LED: u32 = 8;
pub const HID_USAGE_PAGE_BUTTON: u32 = 9;
pub const HID_USAGE_PAGE_ORDINAL: u32 = 10;
pub const HID_USAGE_PAGE_TELEPHONY: u32 = 11;
pub const HID_USAGE_PAGE_CONSUMER: u32 = 12;
pub const HID_USAGE_PAGE_DIGITIZER: u32 = 13;
pub const HID_USAGE_PAGE_UNICODE: u32 = 16;
pub const HID_USAGE_PAGE_ALPHANUMERIC: u32 = 20;
pub const HID_USAGE_GENERIC_POINTER: u32 = 1;
pub const HID_USAGE_GENERIC_MOUSE: u32 = 2;
pub const HID_USAGE_GENERIC_JOYSTICK: u32 = 4;
pub const HID_USAGE_GENERIC_GAMEPAD: u32 = 5;
pub const HID_USAGE_GENERIC_KEYBOARD: u32 = 6;
pub const HID_USAGE_GENERIC_KEYPAD: u32 = 7;
pub const HID_USAGE_GENERIC_X: u32 = 48;
pub const HID_USAGE_GENERIC_Y: u32 = 49;
pub const HID_USAGE_GENERIC_Z: u32 = 50;
pub const HID_USAGE_GENERIC_RX: u32 = 51;
pub const HID_USAGE_GENERIC_RY: u32 = 52;
pub const HID_USAGE_GENERIC_RZ: u32 = 53;
pub const HID_USAGE_GENERIC_SLIDER: u32 = 54;
pub const HID_USAGE_GENERIC_DIAL: u32 = 55;
pub const HID_USAGE_GENERIC_WHEEL: u32 = 56;
pub const HID_USAGE_GENERIC_HATSWITCH: u32 = 57;
pub const HID_USAGE_GENERIC_COUNTED_BUFFER: u32 = 58;
pub const HID_USAGE_GENERIC_BYTE_COUNT: u32 = 59;
pub const HID_USAGE_GENERIC_MOTION_WAKEUP: u32 = 60;
pub const HID_USAGE_GENERIC_VX: u32 = 64;
pub const HID_USAGE_GENERIC_VY: u32 = 65;
pub const HID_USAGE_GENERIC_VZ: u32 = 66;
pub const HID_USAGE_GENERIC_VBRX: u32 = 67;
pub const HID_USAGE_GENERIC_VBRY: u32 = 68;
pub const HID_USAGE_GENERIC_VBRZ: u32 = 69;
pub const HID_USAGE_GENERIC_VNO: u32 = 70;
pub const HID_USAGE_GENERIC_SYSTEM_CTL: u32 = 128;
pub const HID_USAGE_GENERIC_SYSCTL_POWER: u32 = 129;
pub const HID_USAGE_GENERIC_SYSCTL_SLEEP: u32 = 130;
pub const HID_USAGE_GENERIC_SYSCTL_WAKE: u32 = 131;
pub const HID_USAGE_GENERIC_SYSCTL_CONTEXT_MENU: u32 = 132;
pub const HID_USAGE_GENERIC_SYSCTL_MAIN_MENU: u32 = 133;
pub const HID_USAGE_GENERIC_SYSCTL_APP_MENU: u32 = 134;
pub const HID_USAGE_GENERIC_SYSCTL_HELP_MENU: u32 = 135;
pub const HID_USAGE_GENERIC_SYSCTL_MENU_EXIT: u32 = 136;
pub const HID_USAGE_GENERIC_SYSCTL_MENU_SELECT: u32 = 137;
pub const HID_USAGE_GENERIC_SYSCTL_MENU_RIGHT: u32 = 138;
pub const HID_USAGE_GENERIC_SYSCTL_MENU_LEFT: u32 = 139;
pub const HID_USAGE_GENERIC_SYSCTL_MENU_UP: u32 = 140;
pub const HID_USAGE_GENERIC_SYSCTL_MENU_DOWN: u32 = 141;
pub const HID_USAGE_SIMULATION_RUDDER: u32 = 186;
pub const HID_USAGE_SIMULATION_THROTTLE: u32 = 187;
pub const HID_USAGE_KEYBOARD_NOEVENT: u32 = 0;
pub const HID_USAGE_KEYBOARD_ROLLOVER: u32 = 1;
pub const HID_USAGE_KEYBOARD_POSTFAIL: u32 = 2;
pub const HID_USAGE_KEYBOARD_UNDEFINED: u32 = 3;
pub const HID_USAGE_KEYBOARD_aA: u32 = 4;
pub const HID_USAGE_KEYBOARD_zZ: u32 = 29;
pub const HID_USAGE_KEYBOARD_ONE: u32 = 30;
pub const HID_USAGE_KEYBOARD_ZERO: u32 = 39;
pub const HID_USAGE_KEYBOARD_RETURN: u32 = 40;
pub const HID_USAGE_KEYBOARD_ESCAPE: u32 = 41;
pub const HID_USAGE_KEYBOARD_DELETE: u32 = 42;
pub const HID_USAGE_KEYBOARD_F1: u32 = 58;
pub const HID_USAGE_KEYBOARD_F12: u32 = 69;
pub const HID_USAGE_KEYBOARD_PRINT_SCREEN: u32 = 70;
pub const HID_USAGE_KEYBOARD_LCTRL: u32 = 224;
pub const HID_USAGE_KEYBOARD_LSHFT: u32 = 225;
pub const HID_USAGE_KEYBOARD_LALT: u32 = 226;
pub const HID_USAGE_KEYBOARD_LGUI: u32 = 227;
pub const HID_USAGE_KEYBOARD_RCTRL: u32 = 228;
pub const HID_USAGE_KEYBOARD_RSHFT: u32 = 229;
pub const HID_USAGE_KEYBOARD_RALT: u32 = 230;
pub const HID_USAGE_KEYBOARD_RGUI: u32 = 231;
pub const HID_USAGE_KEYBOARD_SCROLL_LOCK: u32 = 71;
pub const HID_USAGE_KEYBOARD_NUM_LOCK: u32 = 83;
pub const HID_USAGE_KEYBOARD_CAPS_LOCK: u32 = 57;
pub const HID_USAGE_LED_NUM_LOCK: u32 = 1;
pub const HID_USAGE_LED_CAPS_LOCK: u32 = 2;
pub const HID_USAGE_LED_SCROLL_LOCK: u32 = 3;
pub const HID_USAGE_LED_COMPOSE: u32 = 4;
pub const HID_USAGE_LED_KANA: u32 = 5;
pub const HID_USAGE_LED_POWER: u32 = 6;
pub const HID_USAGE_LED_SHIFT: u32 = 7;
pub const HID_USAGE_LED_DO_NOT_DISTURB: u32 = 8;
pub const HID_USAGE_LED_MUTE: u32 = 9;
pub const HID_USAGE_LED_TONE_ENABLE: u32 = 10;
pub const HID_USAGE_LED_HIGH_CUT_FILTER: u32 = 11;
pub const HID_USAGE_LED_LOW_CUT_FILTER: u32 = 12;
pub const HID_USAGE_LED_EQUALIZER_ENABLE: u32 = 13;
pub const HID_USAGE_LED_SOUND_FIELD_ON: u32 = 14;
pub const HID_USAGE_LED_SURROUND_FIELD_ON: u32 = 15;
pub const HID_USAGE_LED_REPEAT: u32 = 16;
pub const HID_USAGE_LED_STEREO: u32 = 17;
pub const HID_USAGE_LED_SAMPLING_RATE_DETECT: u32 = 18;
pub const HID_USAGE_LED_SPINNING: u32 = 19;
pub const HID_USAGE_LED_CAV: u32 = 20;
pub const HID_USAGE_LED_CLV: u32 = 21;
pub const HID_USAGE_LED_RECORDING_FORMAT_DET: u32 = 22;
pub const HID_USAGE_LED_OFF_HOOK: u32 = 23;
pub const HID_USAGE_LED_RING: u32 = 24;
pub const HID_USAGE_LED_MESSAGE_WAITING: u32 = 25;
pub const HID_USAGE_LED_DATA_MODE: u32 = 26;
pub const HID_USAGE_LED_BATTERY_OPERATION: u32 = 27;
pub const HID_USAGE_LED_BATTERY_OK: u32 = 28;
pub const HID_USAGE_LED_BATTERY_LOW: u32 = 29;
pub const HID_USAGE_LED_SPEAKER: u32 = 30;
pub const HID_USAGE_LED_HEAD_SET: u32 = 31;
pub const HID_USAGE_LED_HOLD: u32 = 32;
pub const HID_USAGE_LED_MICROPHONE: u32 = 33;
pub const HID_USAGE_LED_COVERAGE: u32 = 34;
pub const HID_USAGE_LED_NIGHT_MODE: u32 = 35;
pub const HID_USAGE_LED_SEND_CALLS: u32 = 36;
pub const HID_USAGE_LED_CALL_PICKUP: u32 = 37;
pub const HID_USAGE_LED_CONFERENCE: u32 = 38;
pub const HID_USAGE_LED_STAND_BY: u32 = 39;
pub const HID_USAGE_LED_CAMERA_ON: u32 = 40;
pub const HID_USAGE_LED_CAMERA_OFF: u32 = 41;
pub const HID_USAGE_LED_ON_LINE: u32 = 42;
pub const HID_USAGE_LED_OFF_LINE: u32 = 43;
pub const HID_USAGE_LED_BUSY: u32 = 44;
pub const HID_USAGE_LED_READY: u32 = 45;
pub const HID_USAGE_LED_PAPER_OUT: u32 = 46;
pub const HID_USAGE_LED_PAPER_JAM: u32 = 47;
pub const HID_USAGE_LED_REMOTE: u32 = 48;
pub const HID_USAGE_LED_FORWARD: u32 = 49;
pub const HID_USAGE_LED_REVERSE: u32 = 50;
pub const HID_USAGE_LED_STOP: u32 = 51;
pub const HID_USAGE_LED_REWIND: u32 = 52;
pub const HID_USAGE_LED_FAST_FORWARD: u32 = 53;
pub const HID_USAGE_LED_PLAY: u32 = 54;
pub const HID_USAGE_LED_PAUSE: u32 = 55;
pub const HID_USAGE_LED_RECORD: u32 = 56;
pub const HID_USAGE_LED_ERROR: u32 = 57;
pub const HID_USAGE_LED_SELECTED_INDICATOR: u32 = 58;
pub const HID_USAGE_LED_IN_USE_INDICATOR: u32 = 59;
pub const HID_USAGE_LED_MULTI_MODE_INDICATOR: u32 = 60;
pub const HID_USAGE_LED_INDICATOR_ON: u32 = 61;
pub const HID_USAGE_LED_INDICATOR_FLASH: u32 = 62;
pub const HID_USAGE_LED_INDICATOR_SLOW_BLINK: u32 = 63;
pub const HID_USAGE_LED_INDICATOR_FAST_BLINK: u32 = 64;
pub const HID_USAGE_LED_INDICATOR_OFF: u32 = 65;
pub const HID_USAGE_LED_FLASH_ON_TIME: u32 = 66;
pub const HID_USAGE_LED_SLOW_BLINK_ON_TIME: u32 = 67;
pub const HID_USAGE_LED_SLOW_BLINK_OFF_TIME: u32 = 68;
pub const HID_USAGE_LED_FAST_BLINK_ON_TIME: u32 = 69;
pub const HID_USAGE_LED_FAST_BLINK_OFF_TIME: u32 = 70;
pub const HID_USAGE_LED_INDICATOR_COLOR: u32 = 71;
pub const HID_USAGE_LED_RED: u32 = 72;
pub const HID_USAGE_LED_GREEN: u32 = 73;
pub const HID_USAGE_LED_AMBER: u32 = 74;
pub const HID_USAGE_LED_GENERIC_INDICATOR: u32 = 75;
pub const HID_USAGE_TELEPHONY_PHONE: u32 = 1;
pub const HID_USAGE_TELEPHONY_ANSWERING_MACHINE: u32 = 2;
pub const HID_USAGE_TELEPHONY_MESSAGE_CONTROLS: u32 = 3;
pub const HID_USAGE_TELEPHONY_HANDSET: u32 = 4;
pub const HID_USAGE_TELEPHONY_HEADSET: u32 = 5;
pub const HID_USAGE_TELEPHONY_KEYPAD: u32 = 6;
pub const HID_USAGE_TELEPHONY_PROGRAMMABLE_BUTTON: u32 = 7;
pub const HID_USAGE_CONSUMER_CONTROL: u32 = 1;
pub const HID_USAGE_CONSUMER_FAST_FORWARD: u32 = 179;
pub const HID_USAGE_CONSUMER_REWIND: u32 = 180;
pub const HID_USAGE_CONSUMER_PLAY_PAUSE: u32 = 205;
pub const HID_USAGE_CONSUMER_VOLUME_INCREMENT: u32 = 233;
pub const HID_USAGE_CONSUMER_VOLUME_DECREMENT: u32 = 234;
pub const HID_EndCollection: u32 = 192;
pub const HID_Data: u32 = 0;
pub const HID_Constant: u32 = 1;
pub const HID_Array: u32 = 0;
pub const HID_Variable: u32 = 2;
pub const HID_Absolute: u32 = 0;
pub const HID_Relative: u32 = 4;
pub const HID_NoWrap: u32 = 0;
pub const HID_Wrap: u32 = 8;
pub const HID_Linear: u32 = 0;
pub const HID_NonLinear: u32 = 16;
pub const HID_PreferredState: u32 = 0;
pub const HID_NoPreferred: u32 = 32;
pub const HID_NoNullPosition: u32 = 0;
pub const HID_NullState: u32 = 64;
pub const HID_NonVolatile: u32 = 0;
pub const HID_Volatile: u32 = 128;
pub const HID_Physical: u32 = 0;
pub const HID_Application: u32 = 1;
pub const HID_Logical: u32 = 2;
pub const HID_Report: u32 = 3;
pub const HID_NamedArray: u32 = 4;
pub const HID_UsageSwitch: u32 = 5;
pub const HID_UsageModifier: u32 = 6;
pub const HID_Push: u32 = 160;
pub const HID_Pop: u32 = 176;
pub const CDC_V1_10: u32 = 272;
pub const CDC_COMMUNICATION_INTERFACE_CLASS: u32 = 2;
pub const CDC_DIRECT_LINE_CONTROL_MODEL: u32 = 1;
pub const CDC_ABSTRACT_CONTROL_MODEL: u32 = 2;
pub const CDC_TELEPHONE_CONTROL_MODEL: u32 = 3;
pub const CDC_MULTI_CHANNEL_CONTROL_MODEL: u32 = 4;
pub const CDC_CAPI_CONTROL_MODEL: u32 = 5;
pub const CDC_ETHERNET_NETWORKING_CONTROL_MODEL: u32 = 6;
pub const CDC_ATM_NETWORKING_CONTROL_MODEL: u32 = 7;
pub const CDC_PROTOCOL_COMMON_AT_COMMANDS: u32 = 1;
pub const CDC_DATA_INTERFACE_CLASS: u32 = 10;
pub const CDC_PROTOCOL_ISDN_BRI: u32 = 48;
pub const CDC_PROTOCOL_HDLC: u32 = 49;
pub const CDC_PROTOCOL_TRANSPARENT: u32 = 50;
pub const CDC_PROTOCOL_Q921_MANAGEMENT: u32 = 80;
pub const CDC_PROTOCOL_Q921_DATA_LINK: u32 = 81;
pub const CDC_PROTOCOL_Q921_MULTIPLEXOR: u32 = 82;
pub const CDC_PROTOCOL_V42: u32 = 144;
pub const CDC_PROTOCOL_EURO_ISDN: u32 = 145;
pub const CDC_PROTOCOL_V24_RATE_ADAPTATION: u32 = 146;
pub const CDC_PROTOCOL_CAPI: u32 = 147;
pub const CDC_PROTOCOL_HOST_BASED_DRIVER: u32 = 253;
pub const CDC_PROTOCOL_DESCRIBED_IN_PUFD: u32 = 254;
pub const CDC_CS_INTERFACE: u32 = 36;
pub const CDC_CS_ENDPOINT: u32 = 37;
pub const CDC_HEADER: u32 = 0;
pub const CDC_CALL_MANAGEMENT: u32 = 1;
pub const CDC_ABSTRACT_CONTROL_MANAGEMENT: u32 = 2;
pub const CDC_DIRECT_LINE_MANAGEMENT: u32 = 3;
pub const CDC_TELEPHONE_RINGER: u32 = 4;
pub const CDC_REPORTING_CAPABILITIES: u32 = 5;
pub const CDC_UNION: u32 = 6;
pub const CDC_COUNTRY_SELECTION: u32 = 7;
pub const CDC_TELEPHONE_OPERATIONAL_MODES: u32 = 8;
pub const CDC_USB_TERMINAL: u32 = 9;
pub const CDC_NETWORK_CHANNEL: u32 = 10;
pub const CDC_PROTOCOL_UNIT: u32 = 11;
pub const CDC_EXTENSION_UNIT: u32 = 12;
pub const CDC_MULTI_CHANNEL_MANAGEMENT: u32 = 13;
pub const CDC_CAPI_CONTROL_MANAGEMENT: u32 = 14;
pub const CDC_ETHERNET_NETWORKING: u32 = 15;
pub const CDC_ATM_NETWORKING: u32 = 16;
pub const CDC_SEND_ENCAPSULATED_COMMAND: u32 = 0;
pub const CDC_GET_ENCAPSULATED_RESPONSE: u32 = 1;
pub const CDC_SET_COMM_FEATURE: u32 = 2;
pub const CDC_GET_COMM_FEATURE: u32 = 3;
pub const CDC_CLEAR_COMM_FEATURE: u32 = 4;
pub const CDC_SET_AUX_LINE_STATE: u32 = 16;
pub const CDC_SET_HOOK_STATE: u32 = 17;
pub const CDC_PULSE_SETUP: u32 = 18;
pub const CDC_SEND_PULSE: u32 = 19;
pub const CDC_SET_PULSE_TIME: u32 = 20;
pub const CDC_RING_AUX_JACK: u32 = 21;
pub const CDC_SET_LINE_CODING: u32 = 32;
pub const CDC_GET_LINE_CODING: u32 = 33;
pub const CDC_SET_CONTROL_LINE_STATE: u32 = 34;
pub const CDC_SEND_BREAK: u32 = 35;
pub const CDC_SET_RINGER_PARMS: u32 = 48;
pub const CDC_GET_RINGER_PARMS: u32 = 49;
pub const CDC_SET_OPERATION_PARMS: u32 = 50;
pub const CDC_GET_OPERATION_PARMS: u32 = 51;
pub const CDC_SET_LINE_PARMS: u32 = 52;
pub const CDC_GET_LINE_PARMS: u32 = 53;
pub const CDC_DIAL_DIGITS: u32 = 54;
pub const CDC_SET_UNIT_PARAMETER: u32 = 55;
pub const CDC_GET_UNIT_PARAMETER: u32 = 56;
pub const CDC_CLEAR_UNIT_PARAMETER: u32 = 57;
pub const CDC_GET_PROFILE: u32 = 58;
pub const CDC_SET_ETHERNET_MULTICAST_FILTERS: u32 = 64;
pub const CDC_SET_ETHERNET_PMP_FILTER: u32 = 65;
pub const CDC_GET_ETHERNET_PMP_FILTER: u32 = 66;
pub const CDC_SET_ETHERNET_PACKET_FILTER: u32 = 67;
pub const CDC_GET_ETHERNET_STATISTIC: u32 = 68;
pub const CDC_SET_ATM_DATA_FORMAT: u32 = 80;
pub const CDC_GET_ATM_DEVICE_STATISTICS: u32 = 81;
pub const CDC_SET_ATM_DEFAULT_VC: u32 = 82;
pub const CDC_GET_ATM_VC_STATISTICS: u32 = 83;
pub const CDC_ABSTRACT_STATE: u32 = 1;
pub const CDC_COUNTRY_SETTING: u32 = 2;
pub const CDC_IDLE_SETTING: u32 = 1;
pub const CDC_DATA_MULTPLEXED_STATE: u32 = 2;
pub const CDC_DTE_PRESENT: u32 = 1;
pub const CDC_ACTIVATE_CARRIER: u32 = 2;
pub const CDC_NOTIFICATION_NETWORK_CONNECTION: u32 = 0;
pub const CDC_RESPONSE_AVAILABLE: u32 = 1;
pub const CDC_AUX_JACK_HOOK_STATE: u32 = 8;
pub const CDC_RING_DETECT: u32 = 9;
pub const CDC_NOTIFICATION_SERIAL_STATE: u32 = 32;
pub const CDC_CALL_STATE_CHANGE: u32 = 40;
pub const CDC_LINE_STATE_CHANGE: u32 = 41;
pub const CDC_CONNECTION_SPEED_CHANGE: u32 = 42;
pub const CDC_SERIAL_STATE_OVERRUN: u32 = 64;
pub const CDC_SERIAL_STATE_PARITY: u32 = 32;
pub const CDC_SERIAL_STATE_FRAMING: u32 = 16;
pub const CDC_SERIAL_STATE_RING: u32 = 8;
pub const CDC_SERIAL_STATE_BREAK: u32 = 4;
pub const CDC_SERIAL_STATE_TX_CARRIER: u32 = 2;
pub const CDC_SERIAL_STATE_RX_CARRIER: u32 = 1;
pub const CDC_BUF_SIZE: u32 = 128;
pub const CDC_BUF_MASK: u32 = 127;
#[doc = "< enum value returned on Success"]
pub const ErrorCode_t_LPC_OK: ErrorCode_t = 0;
#[doc = "< enum value returned on general failure"]
pub const ErrorCode_t_ERR_FAILED: ErrorCode_t = -1;
#[doc = "< enum value returned on general timeout"]
pub const ErrorCode_t_ERR_TIME_OUT: ErrorCode_t = -2;
#[doc = "< enum value returned when resource is busy"]
pub const ErrorCode_t_ERR_BUSY: ErrorCode_t = -3;
pub const ErrorCode_t_ERR_ISP_BASE: ErrorCode_t = 0;
pub const ErrorCode_t_ERR_ISP_INVALID_COMMAND: ErrorCode_t = 1;
pub const ErrorCode_t_ERR_ISP_SRC_ADDR_ERROR: ErrorCode_t = 2;
pub const ErrorCode_t_ERR_ISP_DST_ADDR_ERROR: ErrorCode_t = 3;
pub const ErrorCode_t_ERR_ISP_SRC_ADDR_NOT_MAPPED: ErrorCode_t = 4;
pub const ErrorCode_t_ERR_ISP_DST_ADDR_NOT_MAPPED: ErrorCode_t = 5;
pub const ErrorCode_t_ERR_ISP_COUNT_ERROR: ErrorCode_t = 6;
pub const ErrorCode_t_ERR_ISP_INVALID_SECTOR: ErrorCode_t = 7;
pub const ErrorCode_t_ERR_ISP_SECTOR_NOT_BLANK: ErrorCode_t = 8;
pub const ErrorCode_t_ERR_ISP_SECTOR_NOT_PREPARED_FOR_WRITE_OPERATION: ErrorCode_t = 9;
pub const ErrorCode_t_ERR_ISP_COMPARE_ERROR: ErrorCode_t = 10;
pub const ErrorCode_t_ERR_ISP_BUSY: ErrorCode_t = 11;
pub const ErrorCode_t_ERR_ISP_PARAM_ERROR: ErrorCode_t = 12;
pub const ErrorCode_t_ERR_ISP_ADDR_ERROR: ErrorCode_t = 13;
pub const ErrorCode_t_ERR_ISP_ADDR_NOT_MAPPED: ErrorCode_t = 14;
pub const ErrorCode_t_ERR_ISP_CMD_LOCKED: ErrorCode_t = 15;
pub const ErrorCode_t_ERR_ISP_INVALID_CODE: ErrorCode_t = 16;
pub const ErrorCode_t_ERR_ISP_INVALID_BAUD_RATE: ErrorCode_t = 17;
pub const ErrorCode_t_ERR_ISP_INVALID_STOP_BIT: ErrorCode_t = 18;
pub const ErrorCode_t_ERR_ISP_CODE_READ_PROTECTION_ENABLED: ErrorCode_t = 19;
pub const ErrorCode_t_ERR_API_BASE: ErrorCode_t = 65536;
#[doc = "< Invalid parameters"]
pub const ErrorCode_t_ERR_API_INVALID_PARAMS: ErrorCode_t = 65537;
#[doc = "< PARAM1 is invalid"]
pub const ErrorCode_t_ERR_API_INVALID_PARAM1: ErrorCode_t = 65538;
#[doc = "< PARAM2 is invalid"]
pub const ErrorCode_t_ERR_API_INVALID_PARAM2: ErrorCode_t = 65539;
#[doc = "< PARAM3 is invalid"]
pub const ErrorCode_t_ERR_API_INVALID_PARAM3: ErrorCode_t = 65540;
#[doc = "< API is called before module init"]
pub const ErrorCode_t_ERR_API_MOD_INIT: ErrorCode_t = 65541;
pub const ErrorCode_t_ERR_SPIFI_BASE: ErrorCode_t = 131072;
pub const ErrorCode_t_ERR_SPIFI_DEVICE_ERROR: ErrorCode_t = 131073;
pub const ErrorCode_t_ERR_SPIFI_INTERNAL_ERROR: ErrorCode_t = 131074;
pub const ErrorCode_t_ERR_SPIFI_TIMEOUT: ErrorCode_t = 131075;
pub const ErrorCode_t_ERR_SPIFI_OPERAND_ERROR: ErrorCode_t = 131076;
pub const ErrorCode_t_ERR_SPIFI_STATUS_PROBLEM: ErrorCode_t = 131077;
pub const ErrorCode_t_ERR_SPIFI_UNKNOWN_EXT: ErrorCode_t = 131078;
pub const ErrorCode_t_ERR_SPIFI_UNKNOWN_ID: ErrorCode_t = 131079;
pub const ErrorCode_t_ERR_SPIFI_UNKNOWN_TYPE: ErrorCode_t = 131080;
pub const ErrorCode_t_ERR_SPIFI_UNKNOWN_MFG: ErrorCode_t = 131081;
pub const ErrorCode_t_ERR_SEC_BASE: ErrorCode_t = 196608;
pub const ErrorCode_t_ERR_SEC_AES_WRONG_CMD: ErrorCode_t = 196609;
pub const ErrorCode_t_ERR_SEC_AES_NOT_SUPPORTED: ErrorCode_t = 196610;
pub const ErrorCode_t_ERR_SEC_AES_KEY_ALREADY_PROGRAMMED: ErrorCode_t = 196611;
pub const ErrorCode_t_ERR_USBD_BASE: ErrorCode_t = 262144;
#[doc = "< invalid request"]
pub const ErrorCode_t_ERR_USBD_INVALID_REQ: ErrorCode_t = 262145;
#[doc = "< Callback did not process the event"]
pub const ErrorCode_t_ERR_USBD_UNHANDLED: ErrorCode_t = 262146;
#[doc = "< Stall the endpoint on which the call back is called"]
pub const ErrorCode_t_ERR_USBD_STALL: ErrorCode_t = 262147;
#[doc = "< Send ZLP packet on the endpoint on which the call back is called"]
pub const ErrorCode_t_ERR_USBD_SEND_ZLP: ErrorCode_t = 262148;
#[doc = "< Send data packet on the endpoint on which the call back is called"]
pub const ErrorCode_t_ERR_USBD_SEND_DATA: ErrorCode_t = 262149;
#[doc = "< Bad descriptor"]
pub const ErrorCode_t_ERR_USBD_BAD_DESC: ErrorCode_t = 262150;
#[doc = "< Bad config descriptor"]
pub const ErrorCode_t_ERR_USBD_BAD_CFG_DESC: ErrorCode_t = 262151;
#[doc = "< Bad interface descriptor"]
pub const ErrorCode_t_ERR_USBD_BAD_INTF_DESC: ErrorCode_t = 262152;
#[doc = "< Bad endpoint descriptor"]
pub const ErrorCode_t_ERR_USBD_BAD_EP_DESC: ErrorCode_t = 262153;
#[doc = "< Bad alignment of buffer passed."]
pub const ErrorCode_t_ERR_USBD_BAD_MEM_BUF: ErrorCode_t = 262154;
#[doc = "< Too many class handlers."]
pub const ErrorCode_t_ERR_USBD_TOO_MANY_CLASS_HDLR: ErrorCode_t = 262155;
pub const ErrorCode_t_ERR_CGU_BASE: ErrorCode_t = 327680;
pub const ErrorCode_t_ERR_CGU_NOT_IMPL: ErrorCode_t = 327681;
pub const ErrorCode_t_ERR_CGU_INVALID_PARAM: ErrorCode_t = 327682;
pub const ErrorCode_t_ERR_CGU_INVALID_SLICE: ErrorCode_t = 327683;
pub const ErrorCode_t_ERR_CGU_OUTPUT_GEN: ErrorCode_t = 327684;
pub const ErrorCode_t_ERR_CGU_DIV_SRC: ErrorCode_t = 327685;
pub const ErrorCode_t_ERR_CGU_DIV_VAL: ErrorCode_t = 327686;
pub const ErrorCode_t_ERR_CGU_SRC: ErrorCode_t = 327687;
#[doc = " Error code returned by Boot ROM drivers/library functions\n\n  Error codes are a 32-bit value with :\n      - The 16 MSB contains the peripheral code number\n      - The 16 LSB contains an error code number associated to that peripheral"]
pub type ErrorCode_t = ::core::ffi::c_int;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub const Bool_FALSE: Bool = 0;
pub const Bool_TRUE: Bool = 1;
#[doc = " @brief Boolean Type definition"]
pub type Bool = ::core::ffi::c_uint;
pub const FlagStatus_RESET: FlagStatus = 0;
pub const FlagStatus_SET: FlagStatus = 1;
#[doc = " @brief Flag Status and Interrupt Flag Status type definition"]
pub type FlagStatus = ::core::ffi::c_uint;
#[doc = " @brief Flag Status and Interrupt Flag Status type definition"]
pub use self::FlagStatus as IntStatus;
#[doc = " @brief Flag Status and Interrupt Flag Status type definition"]
pub use self::FlagStatus as SetState;
pub const FunctionalState_DISABLE: FunctionalState = 0;
pub const FunctionalState_ENABLE: FunctionalState = 1;
#[doc = " @brief Functional State Definition"]
pub type FunctionalState = ::core::ffi::c_uint;
pub const Status_ERROR: Status = 0;
pub const Status_SUCCESS: Status = 1;
#[doc = " @ Status type definition"]
pub type Status = ::core::ffi::c_uint;
#[doc = "< None Blocking type"]
pub const TRANSFER_BLOCK_T_NONE_BLOCKING: TRANSFER_BLOCK_T = 0;
#[doc = "< Blocking type"]
pub const TRANSFER_BLOCK_T_BLOCKING: TRANSFER_BLOCK_T = 1;
#[doc = " Read/Write transfer type mode (Block or non-block)"]
pub type TRANSFER_BLOCK_T = ::core::ffi::c_uint;
#[doc = " Pointer to Function returning Void (any number of parameters)"]
pub type PFV = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Pointer to Function returning int32_t (any number of parameters)"]
pub type PFI = ::core::option::Option<unsafe extern "C" fn() -> i32>;
#[doc = " LPC type for character type"]
pub type CHAR = ::core::ffi::c_char;
#[doc = " LPC type for 8 bit unsigned value"]
pub type UNS_8 = u8;
#[doc = " LPC type for 8 bit signed value"]
pub type INT_8 = i8;
#[doc = " LPC type for 16 bit unsigned value"]
pub type UNS_16 = u16;
#[doc = " LPC type for 16 bit signed value"]
pub type INT_16 = i16;
#[doc = " LPC type for 32 bit unsigned value"]
pub type UNS_32 = u32;
#[doc = " LPC type for 32 bit signed value"]
pub type INT_32 = i32;
#[doc = " LPC type for 64 bit signed value"]
pub type INT_64 = i64;
#[doc = " LPC type for 64 bit unsigned value"]
pub type UNS_64 = u64;
#[doc = " 32 bit boolean type"]
pub type BOOL_32 = bool;
#[doc = " 16 bit boolean type"]
pub type BOOL_16 = bool;
#[doc = " 8 bit boolean type"]
pub type BOOL_8 = bool;
#[doc = " Structure to pack lower and upper byte to form 16 bit word."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _WB_T {
    #[doc = "< lower byte"]
    pub L: u8,
    #[doc = "< upper byte"]
    pub H: u8,
}
#[doc = " Structure to pack lower and upper byte to form 16 bit word."]
pub type WB_T = _WB_T;
#[doc = " Union of \\ref _WB_T struct and 16 bit word."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union __WORD_BYTE {
    #[doc = "< data member to do 16 bit access"]
    pub W: u16,
    #[doc = "< data member to do 8 bit access"]
    pub WB: WB_T,
}
#[doc = " Union of \\ref _WB_T struct and 16 bit word."]
pub type WORD_BYTE = __WORD_BYTE;
#[doc = " Structure to define 8 bit USB request."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _BM_T {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _BM_T {
    #[inline]
    pub fn Recipient(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_Recipient(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Dir(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Dir(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Recipient: u8, Type: u8, Dir: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let Recipient: u8 = unsafe { ::core::mem::transmute(Recipient) };
            Recipient as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let Type: u8 = unsafe { ::core::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Dir: u8 = unsafe { ::core::mem::transmute(Dir) };
            Dir as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Structure to define 8 bit USB request."]
pub type BM_T = _BM_T;
#[doc = " Union of \\ref _BM_T struct and 8 bit byte."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _REQUEST_TYPE {
    #[doc = "< byte wide access memeber"]
    pub B: u8,
    #[doc = "< bitfield structure access memeber"]
    pub BM: BM_T,
}
#[doc = " Union of \\ref _BM_T struct and 8 bit byte."]
pub type REQUEST_TYPE = _REQUEST_TYPE;
#[doc = " USB Default Control Pipe Setup Packet"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _USB_SETUP_PACKET {
    #[doc = "< This bitmapped field identifies the characteristics\nof the specific request. \\sa _BM_T."]
    pub bmRequestType: REQUEST_TYPE,
    #[doc = "< This field specifies the particular request. The\nType bits in the bmRequestType field modify the meaning\nof this field. \\sa USBD_REQUEST."]
    pub bRequest: u8,
    #[doc = "< Used to pass a parameter to the device, specific\nto the request."]
    pub wValue: WORD_BYTE,
    #[doc = "< Used to pass a parameter to the device, specific\nto the request. The wIndex field is often used in\nrequests to specify an endpoint or an interface."]
    pub wIndex: WORD_BYTE,
    #[doc = "< This field specifies the length of the data\ntransferred during the second phase of the control\ntransfer."]
    pub wLength: u16,
}
#[doc = " USB Default Control Pipe Setup Packet"]
pub type USB_SETUP_PACKET = _USB_SETUP_PACKET;
#[doc = " USB Standard Device Descriptor"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _USB_DEVICE_DESCRIPTOR {
    #[doc = "< Size of this descriptor in bytes."]
    pub bLength: u8,
    #[doc = "< DEVICE Descriptor Type."]
    pub bDescriptorType: u8,
    #[doc = "< BUSB Specification Release Number in\nBinary-Coded Decimal (i.e., 2.10 is 210H).\nThis field identifies the release of the USB\nSpecification with which the device and its\ndescriptors are compliant."]
    pub bcdUSB: u16,
    #[doc = "< Class code (assigned by the USB-IF).\nIf this field is reset to zero, each interface\nwithin a configuration specifies its own\nclass information and the various\ninterfaces operate independently.\\n\nIf this field is set to a value between 1 and\nFEH, the device supports different class\nspecifications on different interfaces and\nthe interfaces may not operate\nindependently. This value identifies the\nclass definition used for the aggregate\ninterfaces. \\n\nIf this field is set to FFH, the device class\nis vendor-specific."]
    pub bDeviceClass: u8,
    #[doc = "< Subclass code (assigned by the USB-IF).\nThese codes are qualified by the value of\nthe bDeviceClass field. \\n\nIf the bDeviceClass field is reset to zero,\nthis field must also be reset to zero. \\n\nIf the bDeviceClass field is not set to FFH,\nall values are reserved for assignment by\nthe USB-IF."]
    pub bDeviceSubClass: u8,
    #[doc = "< Protocol code (assigned by the USB-IF).\nThese codes are qualified by the value of\nthe bDeviceClass and the\nbDeviceSubClass fields. If a device\nsupports class-specific protocols on a\ndevice basis as opposed to an interface\nbasis, this code identifies the protocols\nthat the device uses as defined by the\nspecification of the device class. \\n\nIf this field is reset to zero, the device\ndoes not use class-specific protocols on a\ndevice basis. However, it may use classspecific\nprotocols on an interface basis. \\n\nIf this field is set to FFH, the device uses a\nvendor-specific protocol on a device basis."]
    pub bDeviceProtocol: u8,
    #[doc = "< Maximum packet size for endpoint zero\n(only 8, 16, 32, or 64 are valid). For HS devices\nis fixed to 64."]
    pub bMaxPacketSize0: u8,
    #[doc = "< Vendor ID (assigned by the USB-IF)."]
    pub idVendor: u16,
    #[doc = "< Product ID (assigned by the manufacturer)."]
    pub idProduct: u16,
    #[doc = "< Device release number in binary-coded decimal."]
    pub bcdDevice: u16,
    #[doc = "< Index of string descriptor describing manufacturer."]
    pub iManufacturer: u8,
    #[doc = "< Index of string descriptor describing product."]
    pub iProduct: u8,
    #[doc = "< Index of string descriptor describing the device�s\nserial number."]
    pub iSerialNumber: u8,
    #[doc = "< Number of possible configurations."]
    pub bNumConfigurations: u8,
}
#[doc = " USB Standard Device Descriptor"]
pub type USB_DEVICE_DESCRIPTOR = _USB_DEVICE_DESCRIPTOR;
#[doc = " USB 2.0 Device Qualifier Descriptor"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _USB_DEVICE_QUALIFIER_DESCRIPTOR {
    #[doc = "< Size of descriptor"]
    pub bLength: u8,
    #[doc = "< Device Qualifier Type"]
    pub bDescriptorType: u8,
    #[doc = "< USB specification version number (e.g., 0200H for V2.00)"]
    pub bcdUSB: u16,
    #[doc = "< Class Code"]
    pub bDeviceClass: u8,
    #[doc = "< SubClass Code"]
    pub bDeviceSubClass: u8,
    #[doc = "< Protocol Code"]
    pub bDeviceProtocol: u8,
    #[doc = "< Maximum packet size for other speed"]
    pub bMaxPacketSize0: u8,
    #[doc = "< Number of Other-speed Configurations"]
    pub bNumConfigurations: u8,
    #[doc = "< Reserved for future use, must be zero"]
    pub bReserved: u8,
}
#[doc = " USB 2.0 Device Qualifier Descriptor"]
pub type USB_DEVICE_QUALIFIER_DESCRIPTOR = _USB_DEVICE_QUALIFIER_DESCRIPTOR;
#[doc = " USB Standard Configuration Descriptor"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _USB_CONFIGURATION_DESCRIPTOR {
    #[doc = "< Size of this descriptor in bytes"]
    pub bLength: u8,
    #[doc = "< CONFIGURATION Descriptor Type"]
    pub bDescriptorType: u8,
    #[doc = "< Total length of data returned for this\nconfiguration. Includes the combined length\nof all descriptors (configuration, interface,\nendpoint, and class- or vendor-specific)\nreturned for this configuration."]
    pub wTotalLength: u16,
    #[doc = "< Number of interfaces supported by this configuration"]
    pub bNumInterfaces: u8,
    #[doc = "< Value to use as an argument to the\nSetConfiguration() request to select this\nconfiguration."]
    pub bConfigurationValue: u8,
    #[doc = "< Index of string descriptor describing this\nconfiguration"]
    pub iConfiguration: u8,
    #[doc = "< Configuration characteristics \\n\nD7: Reserved (set to one)\\n\nD6: Self-powered \\n\nD5: Remote Wakeup \\n\nD4...0: Reserved (reset to zero) \\n\nD7 is reserved and must be set to one for\nhistorical reasons. \\n\nA device configuration that uses power from\nthe bus and a local source reports a non-zero\nvalue in bMaxPower to indicate the amount of\nbus power required and sets D6. The actual\npower source at runtime may be determined\nusing the GetStatus(DEVICE) request (see\nUSB 2.0 spec Section 9.4.5). \\n\nIf a device configuration supports remote\nwakeup, D5 is set to one."]
    pub bmAttributes: u8,
    #[doc = "< Maximum power consumption of the USB\ndevice from the bus in this specific\nconfiguration when the device is fully\noperational. Expressed in 2 mA units\n(i.e., 50 = 100 mA). \\n\nNote: A device configuration reports whether\nthe configuration is bus-powered or selfpowered.\nDevice status reports whether the\ndevice is currently self-powered. If a device is\ndisconnected from its external power source, it\nupdates device status to indicate that it is no\nlonger self-powered. \\n\nA device may not increase its power draw\nfrom the bus, when it loses its external power\nsource, beyond the amount reported by its\nconfiguration. \\n\nIf a device can continue to operate when\ndisconnected from its external power source, it\ncontinues to do so. If the device cannot\ncontinue to operate, it fails operations it can\nno longer support. The USB System Software\nmay determine the cause of the failure by\nchecking the status and noting the loss of the\ndevice�s power source."]
    pub bMaxPower: u8,
}
#[doc = " USB Standard Configuration Descriptor"]
pub type USB_CONFIGURATION_DESCRIPTOR = _USB_CONFIGURATION_DESCRIPTOR;
#[doc = " USB Standard Interface Association Descriptor"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _USB_IAD_DESCRIPTOR {
    #[doc = "< Size of this descriptor in bytes"]
    pub bLength: u8,
    #[doc = "< INTERFACE ASSOCIATION Descriptor Type"]
    pub bDescriptorType: u8,
    #[doc = "< Interface number of the first interface that is\nassociated with this function."]
    pub bFirstInterface: u8,
    #[doc = "< Number of contiguous interfaces that are\nassociated with this function."]
    pub bInterfaceCount: u8,
    #[doc = "< Class code (assigned by USB-IF). \\n\nA value of zero is not allowed in this descriptor.\nIf this field is FFH, the function class is vendorspecific.\nAll other values are reserved for assignment by\nthe USB-IF."]
    pub bFunctionClass: u8,
    #[doc = "< Subclass code (assigned by USB-IF). \\n\nIf the bFunctionClass field is not set to FFH all\nvalues are reserved for assignment by the USBIF."]
    pub bFunctionSubClass: u8,
    #[doc = "< Protocol code (assigned by the USB). \\n\nThese codes are qualified by the values of the\nbFunctionClass and bFunctionSubClass fields."]
    pub bFunctionProtocol: u8,
    #[doc = "< Index of string descriptor describing this function."]
    pub iFunction: u8,
}
#[doc = " USB Standard Interface Association Descriptor"]
pub type USB_IAD_DESCRIPTOR = _USB_IAD_DESCRIPTOR;
#[doc = " USB Standard Interface Descriptor"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _USB_INTERFACE_DESCRIPTOR {
    #[doc = "< Size of this descriptor in bytes"]
    pub bLength: u8,
    #[doc = "< INTERFACE Descriptor Type"]
    pub bDescriptorType: u8,
    #[doc = "< Number of this interface. Zero-based\nvalue identifying the index in the array of\nconcurrent interfaces supported by this\nconfiguration."]
    pub bInterfaceNumber: u8,
    #[doc = "< Value used to select this alternate setting\nfor the interface identified in the prior field"]
    pub bAlternateSetting: u8,
    #[doc = "< Number of endpoints used by this\ninterface (excluding endpoint zero). If this\nvalue is zero, this interface only uses the\nDefault Control Pipe."]
    pub bNumEndpoints: u8,
    #[doc = "< Class code (assigned by the USB-IF). \\n\nA value of zero is reserved for future\nstandardization. \\n\nIf this field is set to FFH, the interface\nclass is vendor-specific. \\n\nAll other values are reserved for\nassignment by the USB-IF."]
    pub bInterfaceClass: u8,
    #[doc = "< Subclass code (assigned by the USB-IF). \\n\nThese codes are qualified by the value of\nthe bInterfaceClass field. \\n\nIf the bInterfaceClass field is reset to zero,\nthis field must also be reset to zero. \\n\nIf the bInterfaceClass field is not set to\nFFH, all values are reserved for\nassignment by the USB-IF."]
    pub bInterfaceSubClass: u8,
    #[doc = "< Protocol code (assigned by the USB). \\n\nThese codes are qualified by the value of\nthe bInterfaceClass and the\nbInterfaceSubClass fields. If an interface\nsupports class-specific requests, this code\nidentifies the protocols that the device\nuses as defined by the specification of the\ndevice class. \\n\nIf this field is reset to zero, the device\ndoes not use a class-specific protocol on\nthis interface. \\n\nIf this field is set to FFH, the device uses\na vendor-specific protocol for this\ninterface."]
    pub bInterfaceProtocol: u8,
    #[doc = "< Index of string descriptor describing this interface"]
    pub iInterface: u8,
}
#[doc = " USB Standard Interface Descriptor"]
pub type USB_INTERFACE_DESCRIPTOR = _USB_INTERFACE_DESCRIPTOR;
#[doc = " USB Standard Endpoint Descriptor"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _USB_ENDPOINT_DESCRIPTOR {
    #[doc = "< Size of this descriptor in bytes"]
    pub bLength: u8,
    #[doc = "< ENDPOINT Descriptor Type"]
    pub bDescriptorType: u8,
    #[doc = "< The address of the endpoint on the USB device\ndescribed by this descriptor. The address is\nencoded as follows: \\n\nBit 3...0: The endpoint number \\n\nBit 6...4: Reserved, reset to zero \\n\nBit 7: Direction, ignored for control endpoints\n0 = OUT endpoint\n1 = IN endpoint.  \\n \\sa USBD_ENDPOINT_ADR_Type"]
    pub bEndpointAddress: u8,
    #[doc = "< This field describes the endpoint�s attributes when it is\nconfigured using the bConfigurationValue. \\n\nBits 1..0: Transfer Type\n\\li 00 = Control\n\\li 01 = Isochronous\n\\li 10 = Bulk\n\\li 11 = Interrupt  \\n\nIf not an isochronous endpoint, bits 5..2 are reserved\nand must be set to zero. If isochronous, they are\ndefined as follows: \\n\nBits 3..2: Synchronization Type\n\\li 00 = No Synchronization\n\\li 01 = Asynchronous\n\\li 10 = Adaptive\n\\li 11 = Synchronous \\n\nBits 5..4: Usage Type\n\\li 00 = Data endpoint\n\\li 01 = Feedback endpoint\n\\li 10 = Implicit feedback Data endpoint\n\\li 11 = Reserved \\n\nRefer to Chapter 5 of USB 2.0 specification for more information. \\n\nAll other bits are reserved and must be reset to zero.\nReserved bits must be ignored by the host.\n\\n \\sa USBD_EP_ATTR_Type"]
    pub bmAttributes: u8,
    #[doc = "< Maximum packet size this endpoint is capable of\nsending or receiving when this configuration is\nselected. \\n\nFor isochronous endpoints, this value is used to\nreserve the bus time in the schedule, required for the\nper-(micro)frame data payloads. The pipe may, on an\nongoing basis, actually use less bandwidth than that\nreserved. The device reports, if necessary, the actual\nbandwidth used via its normal, non-USB defined\nmechanisms. \\n\nFor all endpoints, bits 10..0 specify the maximum\npacket size (in bytes). \\n\nFor high-speed isochronous and interrupt endpoints: \\n\nBits 12..11 specify the number of additional transaction\nopportunities per microframe: \\n\n\\li 00 = None (1 transaction per microframe)\n\\li 01 = 1 additional (2 per microframe)\n\\li 10 = 2 additional (3 per microframe)\n\\li 11 = Reserved \\n\nBits 15..13 are reserved and must be set to zero."]
    pub wMaxPacketSize: u16,
    #[doc = "< Interval for polling endpoint for data transfers.\nExpressed in frames or microframes depending on the\ndevice operating speed (i.e., either 1 millisecond or\n125 �s units).\n\\li For full-/high-speed isochronous endpoints, this value\nmust be in the range from 1 to 16. The bInterval value\nis used as the exponent for a \\f$ 2^(bInterval-1) \\f$ value; e.g., a\nbInterval of 4 means a period of 8 (\\f$ 2^(4-1) \\f$).\n\\li For full-/low-speed interrupt endpoints, the value of\nthis field may be from 1 to 255.\n\\li For high-speed interrupt endpoints, the bInterval value\nis used as the exponent for a \\f$ 2^(bInterval-1) \\f$ value; e.g., a\nbInterval of 4 means a period of 8 (\\f$ 2^(4-1) \\f$) . This value\nmust be from 1 to 16.\n\\li For high-speed bulk/control OUT endpoints, the\nbInterval must specify the maximum NAK rate of the\nendpoint. A value of 0 indicates the endpoint never\nNAKs. Other values indicate at most 1 NAK each\nbInterval number of microframes. This value must be\nin the range from 0 to 255. \\n\nRefer to Chapter 5 of USB 2.0 specification for more information."]
    pub bInterval: u8,
}
#[doc = " USB Standard Endpoint Descriptor"]
pub type USB_ENDPOINT_DESCRIPTOR = _USB_ENDPOINT_DESCRIPTOR;
#[doc = " USB String Descriptor"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _USB_STRING_DESCRIPTOR {
    #[doc = "< Size of this descriptor in bytes"]
    pub bLength: u8,
    #[doc = "< STRING Descriptor Type"]
    pub bDescriptorType: u8,
    #[doc = "< UNICODE encoded string"]
    pub bString: u16,
}
#[doc = " USB String Descriptor"]
pub type USB_STRING_DESCRIPTOR = _USB_STRING_DESCRIPTOR;
#[doc = " USB Common Descriptor"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _USB_COMMON_DESCRIPTOR {
    #[doc = "< Size of this descriptor in bytes"]
    pub bLength: u8,
    #[doc = "< Descriptor Type"]
    pub bDescriptorType: u8,
}
#[doc = " USB Common Descriptor"]
pub type USB_COMMON_DESCRIPTOR = _USB_COMMON_DESCRIPTOR;
#[doc = " USB Other Speed Configuration"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _USB_OTHER_SPEED_CONFIGURATION {
    #[doc = "< Size of descriptor"]
    pub bLength: u8,
    #[doc = "< Other_speed_Configuration Type"]
    pub bDescriptorType: u8,
    #[doc = "< Total length of data returned"]
    pub wTotalLength: u16,
    #[doc = "< Number of interfaces supported by this speed configuration"]
    pub bNumInterfaces: u8,
    #[doc = "< Value to use to select configuration"]
    pub bConfigurationValue: u8,
    #[doc = "< Index of string descriptor"]
    pub IConfiguration: u8,
    #[doc = "< Same as Configuration descriptor"]
    pub bmAttributes: u8,
    #[doc = "< Same as Configuration descriptor"]
    pub bMaxPower: u8,
}
#[doc = " USB Other Speed Configuration"]
pub type USB_OTHER_SPEED_CONFIGURATION = _USB_OTHER_SPEED_CONFIGURATION;
#[doc = " \\ingroup USBD_Core\n USB device stack/module handle."]
pub type USBD_HANDLE_T = *mut ::core::ffi::c_void;
#[doc = " \\ingroup USBD_Core\n  \\typedef USB_CB_T\n  \\brief USB device stack's event callback function type.\n\n  The USB device stack exposes several event triggers through callback to application layer. The\n  application layer can register methods to be called when such USB event happens.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  Other error conditions.\n"]
pub type USB_CB_T =
    ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T) -> ErrorCode_t>;
#[doc = " \\ingroup USBD_Core\n  \\typedef USB_PARAM_CB_T\n  \\brief USB device stack's event callback function type.\n\n  The USB device stack exposes several event triggers through callback to application layer. The\n  application layer can register methods to be called when such USB event happens.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] param1 Extra information related to the event.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
pub type USB_PARAM_CB_T =
    ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T, param1: u32) -> ErrorCode_t>;
#[doc = " \\ingroup USBD_Core\n  \\typedef USB_EP_HANDLER_T\n  \\brief USBD setup request and endpoint event handler type.\n\n  The application layer should define the custom class's EP0 handler with function signature.\n  The stack calls all the registered class handlers on any EP0 event before going through default\n  handling of the event. This gives the class handlers to implement class specific request handlers\n  and also to override the default stack handling for a particular event targeted to the interface.\n  If an event is not handled by the callback the function should return ERR_USBD_UNHANDLED. For all\n  other return codes the stack assumes that callback has taken care of the event and hence will not\n  process the event any further and issues a STALL condition on EP0 indicating error to the host.\n  \\n\n  For endpoint interrupt handler the return value is ignored by the stack.\n  \\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] data Pointer to the data which will be passed when callback function is called by the stack.\n  \\param[in] event  Type of endpoint event. See \\ref USBD_EVENT_T for more details.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
pub type USB_EP_HANDLER_T = ::core::option::Option<
    unsafe extern "C" fn(
        hUsb: USBD_HANDLE_T,
        data: *mut ::core::ffi::c_void,
        event: u32,
    ) -> ErrorCode_t,
>;
#[doc = " \\ingroup USBD_Core\n  \\brief USB descriptors data structure.\n  \\ingroup USBD_Core\n\n  \\details  This structure is used as part of USB device stack initialization\n  parameter structure \\ref USBD_API_INIT_PARAM_T. This structure contains\n  pointers to various descriptor arrays needed by the stack. These descriptors\n  are reported to USB host as part of enumerations process.\n\n  \\note All descriptor pointers assigned in this structure should be on 4 byte\n  aligned address boundary."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _USB_CORE_DESCS_T {
    #[doc = "< Pointer to USB device descriptor"]
    pub device_desc: *mut u8,
    #[doc = "< Pointer to array of USB string descriptors"]
    pub string_desc: *mut u8,
    #[doc = "< Pointer to USB device configuration descriptor\n when device is operating in full speed mode."]
    pub full_speed_desc: *mut u8,
    #[doc = "< Pointer to USB device configuration descriptor\n when device is operating in high speed mode. For\n full-speed only implementation this pointer should\n be same as full_speed_desc."]
    pub high_speed_desc: *mut u8,
    #[doc = "< Pointer to USB device qualifier descriptor. For\n full-speed only implementation this pointer should\n be set to null (0)."]
    pub device_qualifier: *mut u8,
}
#[doc = " \\ingroup USBD_Core\n  \\brief USB descriptors data structure.\n  \\ingroup USBD_Core\n\n  \\details  This structure is used as part of USB device stack initialization\n  parameter structure \\ref USBD_API_INIT_PARAM_T. This structure contains\n  pointers to various descriptor arrays needed by the stack. These descriptors\n  are reported to USB host as part of enumerations process.\n\n  \\note All descriptor pointers assigned in this structure should be on 4 byte\n  aligned address boundary."]
pub type USB_CORE_DESCS_T = _USB_CORE_DESCS_T;
#[doc = " \\brief USB device stack initialization parameter data structure.\n  \\ingroup USBD_Core\n\n  \\details  This data structure is used to pass initialization parameters to the\n  USB device stack's init function.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USBD_API_INIT_PARAM {
    #[doc = "< USB device controller's base register address."]
    pub usb_reg_base: u32,
    #[doc = "< Base memory location from where the stack can allocate\ndata and buffers. \\note The memory address set in this field\nshould be accessible by USB DMA controller. Also this value\nshould be aligned on 2048 byte boundary."]
    pub mem_base: u32,
    #[doc = "< The size of memory buffer which stack can use.\n\\note The \\em mem_size should be greater than the size\nreturned by USBD_HW_API::GetMemSize() routine."]
    pub mem_size: u32,
    #[doc = "< max number of endpoints supported by the USB device\ncontroller instance (specified by \\em usb_reg_base field)\nto which this instance of stack is attached."]
    pub max_num_ep: u8,
    pub pad0: [u8; 3usize],
    #[doc = " Event for USB interface reset. This event fires when the USB host requests that the device\n  reset its interface. This event fires after the control endpoint has been automatically\n  configured by the library.\n  \\n\n  \\note This event is called from USB_ISR context and hence is time-critical. Having delays in this\n  callback will prevent the device from enumerating correctly or operate properly.\n"]
    pub USB_Reset_Event: USB_CB_T,
    #[doc = " Event for USB suspend. This event fires when the USB host suspends the device by halting its\n  transmission of Start Of Frame pulses to the device. This is generally hooked in order to move\n  the device over to a low power state until the host wakes up the device.\n  \\n\n  \\note This event is called from USB_ISR context and hence is time-critical. Having delays in this\n  callback will cause other system issues."]
    pub USB_Suspend_Event: USB_CB_T,
    #[doc = " Event for USB wake up or resume. This event fires when a the USB device interface is suspended\n  and the host wakes up the device by supplying Start Of Frame pulses. This is generally\n  hooked to pull the user application out of a low power state and back into normal operating\n  mode.\n  \\n\n  \\note This event is called from USB_ISR context and hence is time-critical. Having delays in this\n  callback will cause other system issues.\n"]
    pub USB_Resume_Event: USB_CB_T,
    #[doc = " Reserved parameter should be set to zero."]
    pub reserved_sbz: USB_CB_T,
    #[doc = " Event for USB Start Of Frame detection, when enabled. This event fires at the start of each USB\n  frame, once per millisecond in full-speed mode or once per 125 microseconds in high-speed mode,\n  and is synchronized to the USB bus.\n\n  This event is time-critical; it is run once per millisecond (full-speed mode) and thus long handlers\n  will significantly degrade device performance. This event should only be enabled when needed to\n  reduce device wake-ups.\n\n  \\note This event is not normally active - it must be manually enabled and disabled via the USB interrupt\n        register.\n        \\n\\n"]
    pub USB_SOF_Event: USB_CB_T,
    #[doc = " Event for remote wake-up configuration, when enabled. This event fires when the USB host\n  request the device to configure itself for remote wake-up capability. The USB host sends\n  this request to device which report remote wake-up capable in their device descriptors,\n  before going to low-power state. The application layer should implement this callback if\n  they have any special on board circuit to trigger remote wake up event. Also application\n  can use this callback to differentiate the following SUSPEND event is caused by cable plug-out\n  or host SUSPEND request. The device can wake-up host only after receiving this callback and\n  remote wake-up feature is enabled by host. To signal remote wake-up the device has to generate\n  resume signaling on bus by calling usapi.hw->WakeUp() routine.\n\n  \\n\\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] param1 When 0 - Clear the wake-up configuration, 1 - Enable the wake-up configuration.\n  \\return The call back should return \\ref ErrorCode_t type to indicate success or error condition."]
    pub USB_WakeUpCfg: USB_PARAM_CB_T,
    #[doc = " Reserved parameter should be set to zero."]
    pub USB_Power_Event: USB_PARAM_CB_T,
    #[doc = " Event for error condition. This event fires when USB device controller detect\n  an error condition in the system.\n\n  \\n\\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] param1 USB device interrupt status register.\n  \\return The call back should return \\ref ErrorCode_t type to indicate success or error condition."]
    pub USB_Error_Event: USB_PARAM_CB_T,
    #[doc = " Event for USB configuration number changed. This event fires when a the USB host changes the\n  selected configuration number. On receiving configuration change request from host, the stack\n  enables/configures the endpoints needed by the new configuration before calling this callback\n  function.\n  \\n\n  \\note This event is called from USB_ISR context and hence is time-critical. Having delays in this\n  callback will prevent the device from enumerating correctly or operate properly.\n"]
    pub USB_Configure_Event: USB_CB_T,
    #[doc = " Event for USB interface setting changed. This event fires when a the USB host changes the\n  interface setting to one of alternate interface settings. On receiving interface change\n  request from host, the stack enables/configures the endpoints needed by the new alternate\n  interface setting before calling this callback function.\n  \\n\n  \\note This event is called from USB_ISR context and hence is time-critical. Having delays in this\n  callback will prevent the device from enumerating correctly or operate properly.\n"]
    pub USB_Interface_Event: USB_CB_T,
    #[doc = " Event for USB feature changed. This event fires when a the USB host send set/clear feature\n  request. The stack handles this request for USB_FEATURE_REMOTE_WAKEUP, USB_FEATURE_TEST_MODE\n  and USB_FEATURE_ENDPOINT_STALL features only. On receiving feature request from host, the\n  stack handle the request appropriately and then calls this callback function.\n  \\n\n  \\note This event is called from USB_ISR context and hence is time-critical. Having delays in this\n  callback will prevent the device from enumerating correctly or operate properly.\n"]
    pub USB_Feature_Event: USB_CB_T,
    #[doc = " Reserved parameter for future use. should be set to zero."]
    pub virt_to_phys:
        ::core::option::Option<unsafe extern "C" fn(vaddr: *mut ::core::ffi::c_void) -> u32>,
    #[doc = " Reserved parameter for future use. should be set to zero."]
    pub cache_flush:
        ::core::option::Option<unsafe extern "C" fn(start_adr: *mut u32, end_adr: *mut u32)>,
}
#[doc = " \\brief USB device stack initialization parameter data structure.\n  \\ingroup USBD_Core\n\n  \\details  This data structure is used to pass initialization parameters to the\n  USB device stack's init function.\n"]
pub type USBD_API_INIT_PARAM_T = USBD_API_INIT_PARAM;
#[doc = " \\brief USBD stack Core API functions structure.\n  \\ingroup USBD_Core\n\n  \\details  This module exposes functions which interact directly with USB device stack's core layer.\n  The application layer uses this component when it has to implement custom class function driver or\n  standard class function driver which is not part of the current USB device stack.\n  The functions exposed by this interface are to register class specific EP0 handlers and corresponding\n  utility functions to manipulate EP0 state machine of the stack. This interface also exposes\n  function to register custom endpoint interrupt handler.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USBD_CORE_API {
    #[doc = " \\fn ErrorCode_t RegisterClassHandler(USBD_HANDLE_T hUsb, USB_EP_HANDLER_T pfn, void* data)\n  Function to register class specific EP0 event handler with USB device stack.\n\n  The application layer uses this function when it has to register the custom class's EP0 handler.\n  The stack calls all the registered class handlers on any EP0 event before going through default\n  handling of the event. This gives the class handlers to implement class specific request handlers\n  and also to override the default stack handling for a particular event targeted to the interface.\n  Check \\ref USB_EP_HANDLER_T for more details on how the callback function should be implemented. Also\n  application layer could use this function to register EP0 handler which responds to vendor specific\n  requests.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] pfn  Class specific EP0 handler function.\n  \\param[in] data Pointer to the data which will be passed when callback function is called by the stack.\n  \\return Returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success\n          \\retval ERR_USBD_TOO_MANY_CLASS_HDLR(0x0004000c)  The number of class handlers registered is\ngreater than the number of handlers allowed by the stack.\n"]
    pub RegisterClassHandler: ::core::option::Option<
        unsafe extern "C" fn(
            hUsb: USBD_HANDLE_T,
            pfn: USB_EP_HANDLER_T,
            data: *mut ::core::ffi::c_void,
        ) -> ErrorCode_t,
    >,
    #[doc = " \\fn ErrorCode_t RegisterEpHandler(USBD_HANDLE_T hUsb, uint32_t ep_index, USB_EP_HANDLER_T pfn, void* data)\n  Function to register interrupt/event handler for the requested endpoint with USB device stack.\n\n  The application layer uses this function to register the endpoint event handler.\n  The stack calls all the registered endpoint handlers when\n  - USB_EVT_OUT or USB_EVT_OUT_NAK events happen for OUT endpoint.\n  - USB_EVT_IN or USB_EVT_IN_NAK events happen for IN endpoint.\n  Check USB_EP_HANDLER_T for more details on how the callback function should be implemented.\n  \\note By default endpoint _NAK events are not enabled. Application should call \\ref USBD_HW_API_T::EnableEvent\n  for the corresponding endpoint.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] ep_index  Endpoint index. Computed as\n                       - For OUT endpoints = 2 * endpoint number eg. for EP2_OUT it is 4.\n                       - For IN endopoints = (2 * endpoint number) + 1 eg. for EP2_IN it is 5.\n  \\param[in] pfn  Endpoint event handler function.\n  \\param[in] data Pointer to the data which will be passed when callback function is called by the stack.\n  \\return Returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success\n          \\retval ERR_API_INVALID_PARAM2  ep_index is outside the boundary ( < 2 * USBD_API_INIT_PARAM_T::max_num_ep).\n"]
    pub RegisterEpHandler: ::core::option::Option<
        unsafe extern "C" fn(
            hUsb: USBD_HANDLE_T,
            ep_index: u32,
            pfn: USB_EP_HANDLER_T,
            data: *mut ::core::ffi::c_void,
        ) -> ErrorCode_t,
    >,
    #[doc = " \\fn void SetupStage(USBD_HANDLE_T hUsb)\n  Function to set EP0 state machine in setup state.\n\n  This function is called by USB stack and the application layer to\n  set the EP0 state machine in setup state. This function will read\n  the setup packet received from USB host into stack's buffer.\n  \\n\n  \\note This interface is provided to users to invoke this function in other\n  scenarios which are not handle by current stack. In most user applications\n  this function is not called directly.Also this function can be used by\n  users who are selectively modifying the USB device stack's standard handlers\n  through callback interface exposed by the stack.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\return Nothing."]
    pub SetupStage: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T)>,
    #[doc = " \\fn void DataInStage(USBD_HANDLE_T hUsb)\n  Function to set EP0 state machine in data_in state.\n\n  This function is called by USB stack and the application layer to\n  set the EP0 state machine in data_in state. This function will write\n  the data present in EP0Data buffer to EP0 FIFO for transmission to host.\n  \\n\n  \\note This interface is provided to users to invoke this function in other\n  scenarios which are not handle by current stack. In most user applications\n  this function is not called directly.Also this function can be used by\n  users who are selectively modifying the USB device stack's standard handlers\n  through callback interface exposed by the stack.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\return Nothing."]
    pub DataInStage: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T)>,
    #[doc = " \\fn void DataOutStage(USBD_HANDLE_T hUsb)\n  Function to set EP0 state machine in data_out state.\n\n  This function is called by USB stack and the application layer to\n  set the EP0 state machine in data_out state. This function will read\n  the control data (EP0 out packets) received from USB host into EP0Data buffer.\n  \\n\n  \\note This interface is provided to users to invoke this function in other\n  scenarios which are not handle by current stack. In most user applications\n  this function is not called directly.Also this function can be used by\n  users who are selectively modifying the USB device stack's standard handlers\n  through callback interface exposed by the stack.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\return Nothing."]
    pub DataOutStage: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T)>,
    #[doc = " \\fn void StatusInStage(USBD_HANDLE_T hUsb)\n  Function to set EP0 state machine in status_in state.\n\n  This function is called by USB stack and the application layer to\n  set the EP0 state machine in status_in state. This function will send\n  zero length IN packet on EP0 to host, indicating positive status.\n  \\n\n  \\note This interface is provided to users to invoke this function in other\n  scenarios which are not handle by current stack. In most user applications\n  this function is not called directly.Also this function can be used by\n  users who are selectively modifying the USB device stack's standard handlers\n  through callback interface exposed by the stack.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\return Nothing."]
    pub StatusInStage: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T)>,
    #[doc = " \\fn void StatusOutStage(USBD_HANDLE_T hUsb)\n  Function to set EP0 state machine in status_out state.\n\n  This function is called by USB stack and the application layer to\n  set the EP0 state machine in status_out state. This function will read\n  the zero length OUT packet received from USB host on EP0.\n  \\n\n  \\note This interface is provided to users to invoke this function in other\n  scenarios which are not handle by current stack. In most user applications\n  this function is not called directly.Also this function can be used by\n  users who are selectively modifying the USB device stack's standard handlers\n  through callback interface exposed by the stack.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\return Nothing."]
    pub StatusOutStage: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T)>,
    #[doc = " \\fn void StallEp0(USBD_HANDLE_T hUsb)\n  Function to set EP0 state machine in stall state.\n\n  This function is called by USB stack and the application layer to\n  generate STALL signaling on EP0 endpoint. This function will also\n  reset the EP0Data buffer.\n  \\n\n  \\note This interface is provided to users to invoke this function in other\n  scenarios which are not handle by current stack. In most user applications\n  this function is not called directly.Also this function can be used by\n  users who are selectively modifying the USB device stack's standard handlers\n  through callback interface exposed by the stack.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\return Nothing."]
    pub StallEp0: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T)>,
}
#[doc = " \\brief USBD stack Core API functions structure.\n  \\ingroup USBD_Core\n\n  \\details  This module exposes functions which interact directly with USB device stack's core layer.\n  The application layer uses this component when it has to implement custom class function driver or\n  standard class function driver which is not part of the current USB device stack.\n  The functions exposed by this interface are to register class specific EP0 handlers and corresponding\n  utility functions to manipulate EP0 state machine of the stack. This interface also exposes\n  function to register custom endpoint interrupt handler.\n"]
pub type USBD_CORE_API_T = USBD_CORE_API;
#[doc = "< 1   Setup Packet received"]
pub const USBD_EVENT_T_USB_EVT_SETUP: USBD_EVENT_T = 1;
#[doc = "< 2   OUT Packet received"]
pub const USBD_EVENT_T_USB_EVT_OUT: USBD_EVENT_T = 2;
#[doc = "< 3    IN Packet sent"]
pub const USBD_EVENT_T_USB_EVT_IN: USBD_EVENT_T = 3;
#[doc = "< 4   OUT Packet - Not Acknowledged"]
pub const USBD_EVENT_T_USB_EVT_OUT_NAK: USBD_EVENT_T = 4;
#[doc = "< 5    IN Packet - Not Acknowledged"]
pub const USBD_EVENT_T_USB_EVT_IN_NAK: USBD_EVENT_T = 5;
#[doc = "< 6   OUT Packet - Stalled"]
pub const USBD_EVENT_T_USB_EVT_OUT_STALL: USBD_EVENT_T = 6;
#[doc = "< 7    IN Packet - Stalled"]
pub const USBD_EVENT_T_USB_EVT_IN_STALL: USBD_EVENT_T = 7;
#[doc = "< 8   DMA OUT EP - End of Transfer"]
pub const USBD_EVENT_T_USB_EVT_OUT_DMA_EOT: USBD_EVENT_T = 8;
#[doc = "< 9   DMA  IN EP - End of Transfer"]
pub const USBD_EVENT_T_USB_EVT_IN_DMA_EOT: USBD_EVENT_T = 9;
#[doc = "< 10  DMA OUT EP - New Descriptor Request"]
pub const USBD_EVENT_T_USB_EVT_OUT_DMA_NDR: USBD_EVENT_T = 10;
#[doc = "< 11  DMA  IN EP - New Descriptor Request"]
pub const USBD_EVENT_T_USB_EVT_IN_DMA_NDR: USBD_EVENT_T = 11;
#[doc = "< 12  DMA OUT EP - Error"]
pub const USBD_EVENT_T_USB_EVT_OUT_DMA_ERR: USBD_EVENT_T = 12;
#[doc = "< 13  DMA  IN EP - Error"]
pub const USBD_EVENT_T_USB_EVT_IN_DMA_ERR: USBD_EVENT_T = 13;
#[doc = "< 14  Reset event recieved"]
pub const USBD_EVENT_T_USB_EVT_RESET: USBD_EVENT_T = 14;
#[doc = "< 15  Start of Frame event"]
pub const USBD_EVENT_T_USB_EVT_SOF: USBD_EVENT_T = 15;
#[doc = "< 16  Device status events"]
pub const USBD_EVENT_T_USB_EVT_DEV_STATE: USBD_EVENT_T = 16;
#[doc = "< 17  Device error events"]
pub const USBD_EVENT_T_USB_EVT_DEV_ERROR: USBD_EVENT_T = 17;
#[doc = " \\ingroup USBD_HW\n  USB Endpoint/class handler Callback Events."]
pub type USBD_EVENT_T = ::core::ffi::c_uint;
#[doc = "  \\brief Hardware API functions structure.\n  \\ingroup USBD_HW\n\n  This module exposes functions which interact directly with USB device controller hardware.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USBD_HW_API {
    #[doc = " \\fn uint32_t GetMemSize(USBD_API_INIT_PARAM_T* param)\n  Function to determine the memory required by the USB device stack's DCD and core layers.\n\n  This function is called by application layer before calling pUsbApi->hw->Init(), to allocate memory used\n  by DCD and core layers. The application should allocate the memory which is accessible by USB\n  controller/DMA controller.\n  \\note Some memory areas are not accessible by all bus masters.\n\n  \\param[in] param Structure containing USB device stack initialization parameters.\n  \\return Returns the required memory size in bytes."]
    pub GetMemSize:
        ::core::option::Option<unsafe extern "C" fn(param: *mut USBD_API_INIT_PARAM_T) -> u32>,
    #[doc = " \\fn ErrorCode_t Init(USBD_HANDLE_T* phUsb, USB_CORE_DESCS_T* pDesc, USBD_API_INIT_PARAM_T* param)\n  Function to initialize USB device stack's DCD and core layers.\n\n  This function is called by application layer to initialize USB hardware and core layers.\n  On successful initialization the function returns a handle to USB device stack which should\n  be passed to the rest of the functions.\n\n  \\param[in,out] phUsb Pointer to the USB device stack handle of type USBD_HANDLE_T.\n  \\param[in]  pDesc Structure containing pointers to various descriptor arrays needed by the stack.\n                    These descriptors are reported to USB host as part of enumerations process.\n  \\param[in]  param Structure containing USB device stack initialization parameters.\n  \\return Returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK(0) On success\n          \\retval ERR_USBD_BAD_MEM_BUF(0x0004000b) When insufficient memory buffer is passed or memory\n                                             is not aligned on 2048 boundary."]
    pub Init: ::core::option::Option<
        unsafe extern "C" fn(
            phUsb: *mut USBD_HANDLE_T,
            pDesc: *mut USB_CORE_DESCS_T,
            param: *mut USBD_API_INIT_PARAM_T,
        ) -> ErrorCode_t,
    >,
    #[doc = " \\fn void Connect(USBD_HANDLE_T hUsb, uint32_t con)\n  Function to make USB device visible/invisible on the USB bus.\n\n  This function is called after the USB initialization. This function uses the soft connect\n  feature to make the device visible on the USB bus. This function is called only after the\n  application is ready to handle the USB data. The enumeration process is started by the\n  host after the device detection. The driver handles the enumeration process according to\n  the USB descriptors passed in the USB initialization function.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] con  States whether to connect (1) or to disconnect (0).\n  \\return Nothing."]
    pub Connect: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T, con: u32)>,
    #[doc = " \\fn void ISR(USBD_HANDLE_T hUsb)\n  Function to USB device controller interrupt events.\n\n  When the user application is active the interrupt handlers are mapped in the user flash\n  space. The user application must provide an interrupt handler for the USB interrupt and\n  call this function in the interrupt handler routine. The driver interrupt handler takes\n  appropriate action according to the data received on the USB bus.\n\n  \\param[in]  hUsb Handle to the USB device stack.\n  \\return Nothing."]
    pub ISR: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T)>,
    #[doc = " \\fn void Reset(USBD_HANDLE_T hUsb)\n  Function to Reset USB device stack and hardware controller.\n\n  Reset USB device stack and hardware controller. Disables all endpoints except EP0.\n  Clears all pending interrupts and resets endpoint transfer queues.\n  This function is called internally by pUsbApi->hw->init() and from reset event.\n\n  \\param[in]  hUsb Handle to the USB device stack.\n  \\return Nothing."]
    pub Reset: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T)>,
    #[doc = " \\fn void ForceFullSpeed(USBD_HANDLE_T hUsb, uint32_t cfg)\n  Function to force high speed USB device to operate in full speed mode.\n\n  This function is useful for testing the behavior of current device when connected\n  to a full speed only hosts.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] cfg  When 1 - set force full-speed or\n                       0 - clear force full-speed.\n  \\return Nothing."]
    pub ForceFullSpeed: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T, cfg: u32)>,
    #[doc = " \\fn void WakeUpCfg(USBD_HANDLE_T hUsb, uint32_t cfg)\n  Function to configure USB device controller to wake-up host on remote events.\n\n  This function is called by application layer to configure the USB device controller\n  to wakeup on remote events. It is recommended to call this function from users's\n  USB_WakeUpCfg() callback routine registered with stack.\n  \\note User's USB_WakeUpCfg() is registered with stack by setting the USB_WakeUpCfg member\n  of USBD_API_INIT_PARAM_T structure before calling pUsbApi->hw->Init() routine.\n  Certain USB device controllers needed to keep some clocks always on to generate\n  resume signaling through pUsbApi->hw->WakeUp(). This hook is provided to support\n  such controllers. In most controllers cases this is an empty routine.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] cfg  When 1 - Configure controller to wake on remote events or\n                       0 - Configure controller not to wake on remote events.\n  \\return Nothing."]
    pub WakeUpCfg: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T, cfg: u32)>,
    #[doc = " \\fn void SetAddress(USBD_HANDLE_T hUsb, uint32_t adr)\n  Function to set USB address assigned by host in device controller hardware.\n\n  This function is called automatically when USB_REQUEST_SET_ADDRESS request is received\n  by the stack from USB host.\n  This interface is provided to users to invoke this function in other scenarios which are not\n  handle by current stack. In most user applications this function is not called directly.\n  Also this function can be used by users who are selectively modifying the USB device stack's\n  standard handlers through callback interface exposed by the stack.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] adr  USB bus Address to which the device controller should respond. Usually\n                  assigned by the USB host.\n  \\return Nothing."]
    pub SetAddress: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T, adr: u32)>,
    #[doc = " \\fn void Configure(USBD_HANDLE_T hUsb, uint32_t cfg)\n  Function to configure device controller hardware with selected configuration.\n\n  This function is called automatically when USB_REQUEST_SET_CONFIGURATION request is received\n  by the stack from USB host.\n  This interface is provided to users to invoke this function in other scenarios which are not\n  handle by current stack. In most user applications this function is not called directly.\n  Also this function can be used by users who are selectively modifying the USB device stack's\n  standard handlers through callback interface exposed by the stack.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] cfg  Configuration index.\n  \\return Nothing."]
    pub Configure: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T, cfg: u32)>,
    #[doc = " \\fn void ConfigEP(USBD_HANDLE_T hUsb, USB_ENDPOINT_DESCRIPTOR *pEPD)\n  Function to configure USB Endpoint according to descriptor.\n\n  This function is called automatically when USB_REQUEST_SET_CONFIGURATION request is received\n  by the stack from USB host. All the endpoints associated with the selected configuration\n  are configured.\n  This interface is provided to users to invoke this function in other scenarios which are not\n  handle by current stack. In most user applications this function is not called directly.\n  Also this function can be used by users who are selectively modifying the USB device stack's\n  standard handlers through callback interface exposed by the stack.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] pEPD Endpoint descriptor structure defined in USB 2.0 specification.\n  \\return Nothing."]
    pub ConfigEP: ::core::option::Option<
        unsafe extern "C" fn(hUsb: USBD_HANDLE_T, pEPD: *mut USB_ENDPOINT_DESCRIPTOR),
    >,
    #[doc = " \\fn void DirCtrlEP(USBD_HANDLE_T hUsb, uint32_t dir)\n  Function to set direction for USB control endpoint EP0.\n\n  This function is called automatically by the stack on need basis.\n  This interface is provided to users to invoke this function in other scenarios which are not\n  handle by current stack. In most user applications this function is not called directly.\n  Also this function can be used by users who are selectively modifying the USB device stack's\n  standard handlers through callback interface exposed by the stack.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] cfg  When 1 - Set EP0 in IN transfer mode\n                       0 - Set EP0 in OUT transfer mode\n  \\return Nothing."]
    pub DirCtrlEP: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T, dir: u32)>,
    #[doc = " \\fn void EnableEP(USBD_HANDLE_T hUsb, uint32_t EPNum)\n  Function to enable selected USB endpoint.\n\n  This function enables interrupts on selected endpoint.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] EPNum  Endpoint number as per USB specification.\n                    ie. An EP1_IN is represented by 0x81 number.\n  \\return Nothing."]
    pub EnableEP: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T, EPNum: u32)>,
    #[doc = " \\fn void DisableEP(USBD_HANDLE_T hUsb, uint32_t EPNum)\n  Function to disable selected USB endpoint.\n\n  This function disables interrupts on selected endpoint.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] EPNum  Endpoint number as per USB specification.\n                    ie. An EP1_IN is represented by 0x81 number.\n  \\return Nothing."]
    pub DisableEP: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T, EPNum: u32)>,
    #[doc = " \\fn void ResetEP(USBD_HANDLE_T hUsb, uint32_t EPNum)\n  Function to reset selected USB endpoint.\n\n  This function flushes the endpoint buffers and resets data toggle logic.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] EPNum  Endpoint number as per USB specification.\n                    ie. An EP1_IN is represented by 0x81 number.\n  \\return Nothing."]
    pub ResetEP: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T, EPNum: u32)>,
    #[doc = " \\fn void SetStallEP(USBD_HANDLE_T hUsb, uint32_t EPNum)\n  Function to STALL selected USB endpoint.\n\n  Generates STALL signaling for requested endpoint.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] EPNum  Endpoint number as per USB specification.\n                    ie. An EP1_IN is represented by 0x81 number.\n  \\return Nothing."]
    pub SetStallEP: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T, EPNum: u32)>,
    #[doc = " \\fn void ClrStallEP(USBD_HANDLE_T hUsb, uint32_t EPNum)\n  Function to clear STALL state for the requested endpoint.\n\n  This function clears STALL state for the requested endpoint.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] EPNum  Endpoint number as per USB specification.\n                    ie. An EP1_IN is represented by 0x81 number.\n  \\return Nothing."]
    pub ClrStallEP: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T, EPNum: u32)>,
    #[doc = " \\fn ErrorCode_t SetTestMode(USBD_HANDLE_T hUsb, uint8_t mode)\n  Function to set high speed USB device controller in requested test mode.\n\n  USB-IF requires the high speed device to be put in various test modes\n  for electrical testing. This USB device stack calls this function whenever\n  it receives USB_REQUEST_CLEAR_FEATURE request for USB_FEATURE_TEST_MODE.\n  Users can put the device in test mode by directly calling this function.\n  Returns ERR_USBD_INVALID_REQ when device controller is full-speed only.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] mode  Test mode defined in USB 2.0 electrical testing specification.\n  \\return Returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK(0) - On success\n          \\retval ERR_USBD_INVALID_REQ(0x00040001) - Invalid test mode or\n                                             Device controller is full-speed only."]
    pub SetTestMode:
        ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T, mode: u8) -> ErrorCode_t>,
    #[doc = " \\fn uint32_t ReadEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData)\n  Function to read data received on the requested endpoint.\n\n  This function is called by USB stack and the application layer to read the data\n  received on the requested endpoint.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] EPNum  Endpoint number as per USB specification.\n                    ie. An EP1_IN is represented by 0x81 number.\n  \\param[in,out] pData Pointer to the data buffer where data is to be copied.\n  \\return Returns the number of bytes copied to the buffer."]
    pub ReadEP: ::core::option::Option<
        unsafe extern "C" fn(hUsb: USBD_HANDLE_T, EPNum: u32, pData: *mut u8) -> u32,
    >,
    #[doc = " \\fn uint32_t ReadReqEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t len)\n  Function to queue read request on the specified endpoint.\n\n  This function is called by USB stack and the application layer to queue a read request\n  on the specified endpoint.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] EPNum  Endpoint number as per USB specification.\n                    ie. An EP1_IN is represented by 0x81 number.\n  \\param[in,out] pData Pointer to the data buffer where data is to be copied. This buffer\n                       address should be accessible by USB DMA master.\n  \\param[in] len  Length of the buffer passed.\n  \\return Returns the length of the requested buffer."]
    pub ReadReqEP: ::core::option::Option<
        unsafe extern "C" fn(hUsb: USBD_HANDLE_T, EPNum: u32, pData: *mut u8, len: u32) -> u32,
    >,
    #[doc = " \\fn uint32_t ReadSetupPkt(USBD_HANDLE_T hUsb, uint32_t EPNum, uint32_t *pData)\n  Function to read setup packet data received on the requested endpoint.\n\n  This function is called by USB stack and the application layer to read setup packet data\n  received on the requested endpoint.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] EPNum  Endpoint number as per USB specification.\n                    ie. An EP0_IN is represented by 0x80 number.\n  \\param[in,out] pData Pointer to the data buffer where data is to be copied.\n  \\return Returns the number of bytes copied to the buffer."]
    pub ReadSetupPkt: ::core::option::Option<
        unsafe extern "C" fn(hUsb: USBD_HANDLE_T, EPNum: u32, pData: *mut u32) -> u32,
    >,
    #[doc = " \\fn uint32_t WriteEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t cnt)\n  Function to write data to be sent on the requested endpoint.\n\n  This function is called by USB stack and the application layer to send data\n  on the requested endpoint.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] EPNum  Endpoint number as per USB specification.\n                    ie. An EP1_IN is represented by 0x81 number.\n  \\param[in] pData Pointer to the data buffer from where data is to be copied.\n  \\param[in] cnt  Number of bytes to write.\n  \\return Returns the number of bytes written."]
    pub WriteEP: ::core::option::Option<
        unsafe extern "C" fn(hUsb: USBD_HANDLE_T, EPNum: u32, pData: *mut u8, cnt: u32) -> u32,
    >,
    #[doc = " \\fn void WakeUp(USBD_HANDLE_T hUsb)\n  Function to generate resume signaling on bus for remote host wakeup.\n\n  This function is called by application layer to remotely wakeup host controller\n  when system is in suspend state. Application should indicate this remote wakeup\n  capability by setting USB_CONFIG_REMOTE_WAKEUP in bmAttributes of Configuration\n  Descriptor. Also this routine will generate resume signalling only if host\n  enables USB_FEATURE_REMOTE_WAKEUP by sending SET_FEATURE request before suspending\n  the bus.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\return Nothing."]
    pub WakeUp: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T)>,
    #[doc = " \\fn void EnableEvent(USBD_HANDLE_T hUsb, uint32_t EPNum, uint32_t event_type, uint32_t enable)\n  Function to enable/disable selected USB event.\n\n  This function enables interrupts on selected endpoint.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] EPNum  Endpoint number corresponding to the event.\n                    ie. An EP1_IN is represented by 0x81 number. For device events\n                    set this param to 0x0.\n  \\param[in] event_type  Type of endpoint event. See \\ref USBD_EVENT_T for more details.\n  \\param[in] enable  1 - enable event, 0 - disable event.\n  \\return Returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK(0) - On success\n          \\retval ERR_USBD_INVALID_REQ(0x00040001) - Invalid event type."]
    pub EnableEvent: ::core::option::Option<
        unsafe extern "C" fn(
            hUsb: USBD_HANDLE_T,
            EPNum: u32,
            event_type: u32,
            enable: u32,
        ) -> ErrorCode_t,
    >,
}
#[doc = "  \\brief Hardware API functions structure.\n  \\ingroup USBD_HW\n\n  This module exposes functions which interact directly with USB device controller hardware.\n"]
pub type USBD_HW_API_T = USBD_HW_API;
extern "C" {
    #[doc = " @cond  DIRECT_API"]
    pub fn hwUSB_GetMemSize(param: *mut USBD_API_INIT_PARAM_T) -> u32;
}
extern "C" {
    pub fn hwUSB_Init(
        phUsb: *mut USBD_HANDLE_T,
        pDesc: *mut USB_CORE_DESCS_T,
        param: *mut USBD_API_INIT_PARAM_T,
    ) -> ErrorCode_t;
}
extern "C" {
    pub fn hwUSB_Connect(hUsb: USBD_HANDLE_T, con: u32);
}
extern "C" {
    pub fn hwUSB_ISR(hUsb: USBD_HANDLE_T);
}
extern "C" {
    pub fn hwUSB_Reset(hUsb: USBD_HANDLE_T);
}
extern "C" {
    pub fn hwUSB_ForceFullSpeed(hUsb: USBD_HANDLE_T, con: u32);
}
extern "C" {
    pub fn hwUSB_WakeUpCfg(hUsb: USBD_HANDLE_T, cfg: u32);
}
extern "C" {
    pub fn hwUSB_SetAddress(hUsb: USBD_HANDLE_T, adr: u32);
}
extern "C" {
    pub fn hwUSB_Configure(hUsb: USBD_HANDLE_T, cfg: u32);
}
extern "C" {
    pub fn hwUSB_ConfigEP(hUsb: USBD_HANDLE_T, pEPD: *mut USB_ENDPOINT_DESCRIPTOR);
}
extern "C" {
    pub fn hwUSB_DirCtrlEP(hUsb: USBD_HANDLE_T, dir: u32);
}
extern "C" {
    pub fn hwUSB_EnableEP(hUsb: USBD_HANDLE_T, EPNum: u32);
}
extern "C" {
    pub fn hwUSB_DisableEP(hUsb: USBD_HANDLE_T, EPNum: u32);
}
extern "C" {
    pub fn hwUSB_ResetEP(hUsb: USBD_HANDLE_T, EPNum: u32);
}
extern "C" {
    pub fn hwUSB_SetStallEP(hUsb: USBD_HANDLE_T, EPNum: u32);
}
extern "C" {
    pub fn hwUSB_ClrStallEP(hUsb: USBD_HANDLE_T, EPNum: u32);
}
extern "C" {
    pub fn hwUSB_SetTestMode(hUsb: USBD_HANDLE_T, mode: u8) -> ErrorCode_t;
}
extern "C" {
    pub fn hwUSB_ReadEP(hUsb: USBD_HANDLE_T, EPNum: u32, pData: *mut u8) -> u32;
}
extern "C" {
    pub fn hwUSB_ReadReqEP(hUsb: USBD_HANDLE_T, EPNum: u32, pData: *mut u8, len: u32) -> u32;
}
extern "C" {
    pub fn hwUSB_ReadSetupPkt(hUsb: USBD_HANDLE_T, arg1: u32, arg2: *mut u32) -> u32;
}
extern "C" {
    pub fn hwUSB_WriteEP(hUsb: USBD_HANDLE_T, EPNum: u32, pData: *mut u8, cnt: u32) -> u32;
}
extern "C" {
    pub fn hwUSB_WakeUp(hUsb: USBD_HANDLE_T);
}
extern "C" {
    pub fn hwUSB_EnableEvent(
        hUsb: USBD_HANDLE_T,
        EPNum: u32,
        event_type: u32,
        enable: u32,
    ) -> ErrorCode_t;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _MSC_CBW {
    pub dSignature: u32,
    pub dTag: u32,
    pub dDataLength: u32,
    pub bmFlags: u8,
    pub bLUN: u8,
    pub bCBLength: u8,
    pub CB: [u8; 16usize],
}
pub type MSC_CBW = _MSC_CBW;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _MSC_CSW {
    pub dSignature: u32,
    pub dTag: u32,
    pub dDataResidue: u32,
    pub bStatus: u8,
}
pub type MSC_CSW = _MSC_CSW;
#[doc = " \\brief Mass Storage class function driver initialization parameter data structure.\n  \\ingroup USBD_MSC\n\n  \\details  This data structure is used to pass initialization parameters to the\n  Mass Storage class function driver's init function.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USBD_MSC_INIT_PARAM {
    #[doc = "< Base memory location from where the stack can allocate\ndata and buffers. \\note The memory address set in this field\nshould be accessible by USB DMA controller. Also this value\nshould be aligned on 4 byte boundary."]
    pub mem_base: u32,
    #[doc = "< The size of memory buffer which stack can use.\n\\note The \\em mem_size should be greater than the size\nreturned by USBD_MSC_API::GetMemSize() routine."]
    pub mem_size: u32,
    #[doc = "< Pointer to the 28 character string. This string is\nsent in response to the SCSI Inquiry command. \\note The data\npointed by the pointer should be of global scope."]
    pub InquiryStr: *mut u8,
    #[doc = "< Number of blocks present in the mass storage device"]
    pub BlockCount: u32,
    #[doc = "< Block size in number of bytes"]
    pub BlockSize: u32,
    #[doc = "< Memory size in number of bytes"]
    pub MemorySize: u32,
    #[doc = " Pointer to the interface descriptor within the descriptor\n array (\\em high_speed_desc) passed to Init() through \\ref USB_CORE_DESCS_T\n structure. The stack assumes both HS and FS use same BULK endpoints."]
    pub intf_desc: *mut u8,
    #[doc = "  MSC Write callback function.\n\n  This function is provided by the application software. This function gets called\n  when host sends a write command.\n\n  \\param[in] offset Destination start address.\n  \\param[in, out] src  Pointer to a pointer to the source of data. Pointer-to-pointer\n                       is used to implement zero-copy buffers. See \\ref USBD_ZeroCopy\n                       for more details on zero-copy concept.\n  \\param[in] length  Number of bytes to be written.\n  \\return Nothing.\n"]
    pub MSC_Write: ::core::option::Option<
        unsafe extern "C" fn(offset: u32, src: *mut *mut u8, length: u32, high_offset: u32),
    >,
    #[doc = "  MSC Read callback function.\n\n  This function is provided by the application software. This function gets called\n  when host sends a read command.\n\n  \\param[in] offset Source start address.\n  \\param[in, out] dst  Pointer to a pointer to the source of data. The MSC function drivers\n         implemented in stack are written with zero-copy model. Meaning the stack doesn't make an\n          extra copy of buffer before writing/reading data from USB hardware FIFO. Hence the\n          parameter is pointer to a pointer containing address buffer (<em>uint8_t** dst</em>).\n          So that the user application can update the buffer pointer instead of copying data to\n          address pointed by the parameter. /note The updated buffer address should be accessible\n          by USB DMA master. If user doesn't want to use zero-copy model, then the user should copy\n          data to the address pointed by the passed buffer pointer parameter and shouldn't change\n          the address value. See \\ref USBD_ZeroCopy for more details on zero-copy concept.\n  \\param[in] length  Number of bytes to be read.\n  \\return Nothing.\n"]
    pub MSC_Read: ::core::option::Option<
        unsafe extern "C" fn(offset: u32, dst: *mut *mut u8, length: u32, high_offset: u32),
    >,
    #[doc = "  MSC Verify callback function.\n\n  This function is provided by the application software. This function gets called\n  when host sends a verify command. The callback function should compare the buffer\n  with the destination memory at the requested offset and\n\n  \\param[in] offset Destination start address.\n  \\param[in] buf  Buffer containing the data sent by the host.\n  \\param[in] length  Number of bytes to verify.\n  \\return Returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK If data in the buffer matches the data at destination\n          \\retval ERR_FAILED  At least one byte is different.\n"]
    pub MSC_Verify: ::core::option::Option<
        unsafe extern "C" fn(
            offset: u32,
            buf: *mut u8,
            length: u32,
            high_offset: u32,
        ) -> ErrorCode_t,
    >,
    #[doc = "  Optional callback function to optimize MSC_Write buffer transfer.\n\n  This function is provided by the application software. This function gets called\n  when host sends SCSI_WRITE10/SCSI_WRITE12 command. The callback function should\n  update the \\em buff_adr pointer so that the stack transfers the data directly\n  to the target buffer. /note The updated buffer address should be accessible\n  by USB DMA master. If user doesn't want to use zero-copy model, then the user\n  should not update the buffer pointer. See \\ref USBD_ZeroCopy for more details\n  on zero-copy concept.\n\n  \\param[in] offset Destination start address.\n  \\param[in,out] buf  Buffer containing the data sent by the host.\n  \\param[in] length  Number of bytes to write.\n  \\return Nothing.\n"]
    pub MSC_GetWriteBuf: ::core::option::Option<
        unsafe extern "C" fn(offset: u32, buff_adr: *mut *mut u8, length: u32, high_offset: u32),
    >,
    #[doc = "  Optional user override-able function to replace the default MSC class handler.\n\n  The application software could override the default EP0 class handler with their\n  own by providing the handler function address as this data member of the parameter\n  structure. Application which like the default handler should set this data member\n  to zero before calling the USBD_MSC_API::Init().\n  \\n\n  \\note\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] data Pointer to the data which will be passed when callback function is called by the stack.\n  \\param[in] event  Type of endpoint event. See \\ref USBD_EVENT_T for more details.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub MSC_Ep0_Hdlr: ::core::option::Option<
        unsafe extern "C" fn(
            hUsb: USBD_HANDLE_T,
            data: *mut ::core::ffi::c_void,
            event: u32,
        ) -> ErrorCode_t,
    >,
    pub MemorySize64: u64,
}
#[doc = " \\brief Mass Storage class function driver initialization parameter data structure.\n  \\ingroup USBD_MSC\n\n  \\details  This data structure is used to pass initialization parameters to the\n  Mass Storage class function driver's init function.\n"]
pub type USBD_MSC_INIT_PARAM_T = USBD_MSC_INIT_PARAM;
#[doc = " \\brief MSC class API functions structure.\n  \\ingroup USBD_MSC\n\n  This module exposes functions which interact directly with USB device controller hardware.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USBD_MSC_API {
    #[doc = " \\fn uint32_t GetMemSize(USBD_MSC_INIT_PARAM_T* param)\n  Function to determine the memory required by the MSC function driver module.\n\n  This function is called by application layer before calling pUsbApi->msc->Init(), to allocate memory used\n  by MSC function driver module. The application should allocate the memory which is accessible by USB\n  controller/DMA controller.\n  \\note Some memory areas are not accessible by all bus masters.\n\n  \\param[in] param Structure containing MSC function driver module initialization parameters.\n  \\return Returns the required memory size in bytes."]
    pub GetMemSize:
        ::core::option::Option<unsafe extern "C" fn(param: *mut USBD_MSC_INIT_PARAM_T) -> u32>,
    #[doc = " \\fn ErrorCode_t init(USBD_HANDLE_T hUsb, USBD_MSC_INIT_PARAM_T* param)\n  Function to initialize MSC function driver module.\n\n  This function is called by application layer to initialize MSC function driver module.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in, out] param Structure containing MSC function driver module initialization parameters.\n  \\return Returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success\n          \\retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte\n              aligned or smaller than required.\n          \\retval ERR_API_INVALID_PARAM2 Either MSC_Write() or MSC_Read() or\n              MSC_Verify() callbacks are not defined.\n          \\retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed.\n          \\retval ERR_USBD_BAD_EP_DESC  Wrong endpoint descriptor is passed."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(hUsb: USBD_HANDLE_T, param: *mut USBD_MSC_INIT_PARAM_T) -> ErrorCode_t,
    >,
}
#[doc = " \\brief MSC class API functions structure.\n  \\ingroup USBD_MSC\n\n  This module exposes functions which interact directly with USB device controller hardware.\n"]
pub type USBD_MSC_API_T = USBD_MSC_API;
pub const dfu_state_DFU_STATE_appIDLE: dfu_state = 0;
pub const dfu_state_DFU_STATE_appDETACH: dfu_state = 1;
pub const dfu_state_DFU_STATE_dfuIDLE: dfu_state = 2;
pub const dfu_state_DFU_STATE_dfuDNLOAD_SYNC: dfu_state = 3;
pub const dfu_state_DFU_STATE_dfuDNBUSY: dfu_state = 4;
pub const dfu_state_DFU_STATE_dfuDNLOAD_IDLE: dfu_state = 5;
pub const dfu_state_DFU_STATE_dfuMANIFEST_SYNC: dfu_state = 6;
pub const dfu_state_DFU_STATE_dfuMANIFEST: dfu_state = 7;
pub const dfu_state_DFU_STATE_dfuMANIFEST_WAIT_RST: dfu_state = 8;
pub const dfu_state_DFU_STATE_dfuUPLOAD_IDLE: dfu_state = 9;
pub const dfu_state_DFU_STATE_dfuERROR: dfu_state = 10;
pub type dfu_state = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _USB_DFU_FUNC_DESCRIPTOR {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bmAttributes: u8,
    pub wDetachTimeOut: u16,
    pub wTransferSize: u16,
    pub bcdDFUVersion: u16,
}
pub type USB_DFU_FUNC_DESCRIPTOR = _USB_DFU_FUNC_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DFU_STATUS {
    pub bStatus: u8,
    pub bwPollTimeout: [u8; 3usize],
    pub bState: u8,
    pub iString: u8,
}
pub type DFU_STATUS_T = _DFU_STATUS;
#[doc = " \\brief USB descriptors data structure.\n  \\ingroup USBD_DFU\n\n  \\details  This module exposes functions which interact directly with USB device stack's core layer.\n  The application layer uses this component when it has to implement custom class function driver or\n  standard class function driver which is not part of the current USB device stack.\n  The functions exposed by this interface are to register class specific EP0 handlers and corresponding\n  utility functions to manipulate EP0 state machine of the stack. This interface also exposes\n  function to register custom endpoint interrupt handler.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USBD_DFU_INIT_PARAM {
    #[doc = "< Base memory location from where the stack can allocate\ndata and buffers. \\note The memory address set in this field\nshould be accessible by USB DMA controller. Also this value\nshould be aligned on 4 byte boundary."]
    pub mem_base: u32,
    #[doc = "< The size of memory buffer which stack can use.\n\\note The \\em mem_size should be greater than the size\nreturned by USBD_DFU_API::GetMemSize() routine."]
    pub mem_size: u32,
    #[doc = "< DFU transfer block size in number of bytes.\nThis value should match the value set in DFU descriptor\nprovided as part of the descriptor array\n(\\em high_speed_desc) passed to Init() through\n\\ref USB_CORE_DESCS_T structure."]
    pub wTransferSize: u16,
    pub pad: u16,
    #[doc = " Pointer to the DFU interface descriptor within the descriptor\n array (\\em high_speed_desc) passed to Init() through \\ref USB_CORE_DESCS_T\n structure."]
    pub intf_desc: *mut u8,
    #[doc = "  DFU Write callback function.\n\n  This function is provided by the application software. This function gets called\n  when host sends a write command. For application using zero-copy buffer scheme\n  this function is called for the first time with \\em length parameter set to 0.\n  The application code should update the buffer pointer.\n\n  \\param[in] block_num Destination start address.\n  \\param[in, out] src  Pointer to a pointer to the source of data. Pointer-to-pointer\n                     is used to implement zero-copy buffers. See \\ref USBD_ZeroCopy\n                     for more details on zero-copy concept.\n  \\param[out] bwPollTimeout  Pointer to a 3 byte buffer which the callback implementer\n                     should fill with the amount of minimum time, in milliseconds,\n                     that the host should wait before sending a subsequent\n                     DFU_GETSTATUS request.\n  \\param[in] length  Number of bytes to be written.\n  \\return Returns DFU_STATUS_ values defined in mw_usbd_dfu.h.\n"]
    pub DFU_Write: ::core::option::Option<
        unsafe extern "C" fn(
            block_num: u32,
            src: *mut *mut u8,
            length: u32,
            bwPollTimeout: *mut u8,
        ) -> u8,
    >,
    #[doc = "  DFU Read callback function.\n\n  This function is provided by the application software. This function gets called\n  when host sends a read command.\n\n  \\param[in] block_num Destination start address.\n  \\param[in, out] dst  Pointer to a pointer to the source of data. Pointer-to-pointer\n                       is used to implement zero-copy buffers. See \\ref USBD_ZeroCopy\n                       for more details on zero-copy concept.\n  \\param[in] length  Amount of data copied to destination buffer.\n  \\return Returns\n                 - DFU_STATUS_ values defined in mw_usbd_dfu.h to return error conditions.\n                 - 0 if there is no more data to be read. Stack will send EOF frame and set\n                     DFU state-machine to dfuIdle state.\n                 - length of the data copied, should be greater than or equal to 16. If the data copied\n                   is less than DFU \\em wTransferSize the stack will send EOF frame and\n                   goes to dfuIdle state.\n"]
    pub DFU_Read: ::core::option::Option<
        unsafe extern "C" fn(block_num: u32, dst: *mut *mut u8, length: u32) -> u32,
    >,
    #[doc = "  DFU done callback function.\n\n  This function is provided by the application software. This function gets called\n  after firmware download completes.\n\n  \\return Nothing.\n"]
    pub DFU_Done: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = "  DFU detach callback function.\n\n  This function is provided by the application software. This function gets called\n  after USB_REQ_DFU_DETACH is received. Applications which set USB_DFU_WILL_DETACH\n  bit in DFU descriptor should define this function. As part of this function\n  application can call Connect() routine to disconnect and then connect back with\n  host. For application which rely on WinUSB based host application should use this\n  feature since USB reset can be invoked only by kernel drivers on Windows host.\n  By implementing this feature host doen't have to issue reset instead the device\n  has to do it automatically by disconnect and connect procedure.\n\n  \\param[in] hUsb Handle DFU control structure.\n  \\return Nothing.\n"]
    pub DFU_Detach: ::core::option::Option<unsafe extern "C" fn(hUsb: USBD_HANDLE_T)>,
    #[doc = "  Optional user override-able function to replace the default DFU class handler.\n\n  The application software could override the default EP0 class handler with their\n  own by providing the handler function address as this data member of the parameter\n  structure. Application which like the default handler should set this data member\n  to zero before calling the USBD_DFU_API::Init().\n  \\n\n  \\note\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] data Pointer to the data which will be passed when callback function is called by the stack.\n  \\param[in] event  Type of endpoint event. See \\ref USBD_EVENT_T for more details.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub DFU_Ep0_Hdlr: ::core::option::Option<
        unsafe extern "C" fn(
            hUsb: USBD_HANDLE_T,
            data: *mut ::core::ffi::c_void,
            event: u32,
        ) -> ErrorCode_t,
    >,
}
#[doc = " \\brief USB descriptors data structure.\n  \\ingroup USBD_DFU\n\n  \\details  This module exposes functions which interact directly with USB device stack's core layer.\n  The application layer uses this component when it has to implement custom class function driver or\n  standard class function driver which is not part of the current USB device stack.\n  The functions exposed by this interface are to register class specific EP0 handlers and corresponding\n  utility functions to manipulate EP0 state machine of the stack. This interface also exposes\n  function to register custom endpoint interrupt handler.\n"]
pub type USBD_DFU_INIT_PARAM_T = USBD_DFU_INIT_PARAM;
#[doc = " \\brief DFU class API functions structure.\n  \\ingroup USBD_DFU\n\n  This module exposes functions which interact directly with USB device controller hardware.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USBD_DFU_API {
    #[doc = " \\fn uint32_t GetMemSize(USBD_DFU_INIT_PARAM_T* param)\n  Function to determine the memory required by the DFU function driver module.\n\n  This function is called by application layer before calling pUsbApi->dfu->Init(), to allocate memory used\n  by DFU function driver module. The application should allocate the memory which is accessible by USB\n  controller/DMA controller.\n  \\note Some memory areas are not accessible by all bus masters.\n\n  \\param[in] param Structure containing DFU function driver module initialization parameters.\n  \\return Returns the required memory size in bytes."]
    pub GetMemSize:
        ::core::option::Option<unsafe extern "C" fn(param: *mut USBD_DFU_INIT_PARAM_T) -> u32>,
    #[doc = " \\fn ErrorCode_t init(USBD_HANDLE_T hUsb, USBD_DFU_INIT_PARAM_T* param)\n  Function to initialize DFU function driver module.\n\n  This function is called by application layer to initialize DFU function driver module.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in, out] param Structure containing DFU function driver module initialization parameters.\n  \\return Returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success\n          \\retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte aligned or smaller than required.\n          \\retval ERR_API_INVALID_PARAM2 Either DFU_Write() or DFU_Done() or DFU_Read() call-backs are not defined.\n          \\retval ERR_USBD_BAD_DESC\n            - USB_DFU_DESCRIPTOR_TYPE is not defined immediately after\n              interface descriptor.\n            - wTransferSize in descriptor doesn't match the value passed\n              in param->wTransferSize.\n            - DFU_Detach() is not defined while USB_DFU_WILL_DETACH is set\n              in DFU descriptor.\n          \\retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            hUsb: USBD_HANDLE_T,
            param: *mut USBD_DFU_INIT_PARAM_T,
            init_state: u32,
        ) -> ErrorCode_t,
    >,
}
#[doc = " \\brief DFU class API functions structure.\n  \\ingroup USBD_DFU\n\n  This module exposes functions which interact directly with USB device controller hardware.\n"]
pub type USBD_DFU_API_T = USBD_DFU_API;
#[doc = " \\brief HID class-specific HID Descriptor.\n\n  Type define for the HID class-specific HID descriptor, to describe the HID device's specifications. Refer to the HID\n  specification for details on the structure elements.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _HID_DESCRIPTOR {
    #[doc = "< Size of the descriptor, in bytes."]
    pub bLength: u8,
    #[doc = "< Type of HID descriptor."]
    pub bDescriptorType: u8,
    #[doc = "< BCD encoded version that the HID descriptor and device complies to."]
    pub bcdHID: u16,
    #[doc = "< Country code of the localized device, or zero if universal."]
    pub bCountryCode: u8,
    #[doc = "< Total number of HID report descriptors for the interface."]
    pub bNumDescriptors: u8,
    #[doc = "< Array of one or more descriptors"]
    pub DescriptorList: [_HID_DESCRIPTOR__HID_DESCRIPTOR_LIST; 1usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _HID_DESCRIPTOR__HID_DESCRIPTOR_LIST {
    #[doc = "< Type of HID report."]
    pub bDescriptorType: u8,
    #[doc = "< Length of the associated HID report descriptor, in bytes."]
    pub wDescriptorLength: u16,
}
#[doc = " \\brief HID class-specific HID Descriptor.\n\n  Type define for the HID class-specific HID descriptor, to describe the HID device's specifications. Refer to the HID\n  specification for details on the structure elements.\n"]
pub type HID_DESCRIPTOR = _HID_DESCRIPTOR;
#[doc = " \\brief HID report descriptor data structure.\n  \\ingroup USBD_HID\n\n  \\details  This structure is used as part of HID function driver initialization\n  parameter structure \\ref USBD_HID_INIT_PARAM. This structure contains\n  details of a report type supported by the application. An application\n  can support multiple report types as a single HID device. The application\n  should define this report type data structure per report it supports and\n  the array of report types to USBD_HID_API::init() through \\ref USBD_HID_INIT_PARAM\n  structure.\n\n  \\note All descriptor pointers assigned in this structure should be on 4 byte\n  aligned address boundary.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HID_REPORT_T {
    #[doc = "< Size of the report descriptor in bytes."]
    pub len: u16,
    #[doc = "< This value is used by stack to respond to Set_Idle &\nGET_Idle requests for the specified report ID. The value\nof this field specified the rate at which duplicate reports\nare generated for the specified Report ID. For example, a\ndevice with two input reports could specify an idle rate of\n20 milliseconds for report ID 1 and 500 milliseconds for\nreport ID 2."]
    pub idle_time: u8,
    #[doc = "< Padding space."]
    pub __pad: u8,
    #[doc = "< Report descriptor."]
    pub desc: *mut u8,
}
#[doc = " \\brief HID report descriptor data structure.\n  \\ingroup USBD_HID\n\n  \\details  This structure is used as part of HID function driver initialization\n  parameter structure \\ref USBD_HID_INIT_PARAM. This structure contains\n  details of a report type supported by the application. An application\n  can support multiple report types as a single HID device. The application\n  should define this report type data structure per report it supports and\n  the array of report types to USBD_HID_API::init() through \\ref USBD_HID_INIT_PARAM\n  structure.\n\n  \\note All descriptor pointers assigned in this structure should be on 4 byte\n  aligned address boundary.\n"]
pub type USB_HID_REPORT_T = _HID_REPORT_T;
#[doc = " \\brief USB descriptors data structure.\n  \\ingroup USBD_HID\n\n  \\details  This module exposes functions which interact directly with USB device stack's core layer.\n  The application layer uses this component when it has to implement custom class function driver or\n  standard class function driver which is not part of the current USB device stack.\n  The functions exposed by this interface are to register class specific EP0 handlers and corresponding\n  utility functions to manipulate EP0 state machine of the stack. This interface also exposes\n  function to register custom endpoint interrupt handler.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USBD_HID_INIT_PARAM {
    #[doc = "< Base memory location from where the stack can allocate\ndata and buffers. \\note The memory address set in this field\nshould be accessible by USB DMA controller. Also this value\nshould be aligned on 4 byte boundary."]
    pub mem_base: u32,
    #[doc = "< The size of memory buffer which stack can use.\n\\note The \\em mem_size should be greater than the size\nreturned by USBD_HID_API::GetMemSize() routine."]
    pub mem_size: u32,
    #[doc = "< Number of HID reports supported by this instance\nof HID class driver."]
    pub max_reports: u8,
    pub pad: [u8; 3usize],
    #[doc = "< Pointer to the HID interface descriptor within the\ndescriptor array (\\em high_speed_desc) passed to Init()\nthrough \\ref USB_CORE_DESCS_T structure."]
    pub intf_desc: *mut u8,
    #[doc = "< Pointer to an array of HID report descriptor\ndata structure (\\ref USB_HID_REPORT_T). The number\nof elements in the array should be same a \\em max_reports\nvalue. The stack uses this array to respond to\nrequests received for various HID report descriptor\ninformation. \\note This array should be of global scope."]
    pub report_data: *mut USB_HID_REPORT_T,
    #[doc = "  HID get report callback function.\n\n  This function is provided by the application software. This function gets called\n  when host sends a HID_REQUEST_GET_REPORT request. The setup packet data (\\em pSetup)\n  is passed to the callback so that application can extract the report ID, report\n  type and other information need to generate the report. \\note HID reports are sent\n  via interrupt IN endpoint also. This function is called only when report request\n  is received on control endpoint. Application should implement \\em HID_EpIn_Hdlr to\n  send reports to host via interrupt IN endpoint.\n\n\n  \\param[in] hHid Handle to HID function driver.\n  \\param[in] pSetup Pointer to setup packet received from host.\n  \\param[in, out] pBuffer  Pointer to a pointer of data buffer containing report data.\n                       Pointer-to-pointer is used to implement zero-copy buffers.\n                       See \\ref USBD_ZeroCopy for more details on zero-copy concept.\n  \\param[in] length  Amount of data copied to destination buffer.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub HID_GetReport: ::core::option::Option<
        unsafe extern "C" fn(
            hHid: USBD_HANDLE_T,
            pSetup: *mut USB_SETUP_PACKET,
            pBuffer: *mut *mut u8,
            length: *mut u16,
        ) -> ErrorCode_t,
    >,
    #[doc = "  HID set report callback function.\n\n  This function is provided by the application software. This function gets called\n  when host sends a HID_REQUEST_SET_REPORT request. The setup packet data (\\em pSetup)\n  is passed to the callback so that application can extract the report ID, report\n  type and other information need to modify the report. An application might choose\n  to ignore input Set_Report requests as meaningless. Alternatively these reports\n  could be used to reset the origin of a control (that is, current position should\n  report zero).\n\n  \\param[in] hHid Handle to HID function driver.\n  \\param[in] pSetup Pointer to setup packet received from host.\n  \\param[in, out] pBuffer  Pointer to a pointer of data buffer containing report data.\n                       Pointer-to-pointer is used to implement zero-copy buffers.\n                       See \\ref USBD_ZeroCopy for more details on zero-copy concept.\n  \\param[in] length  Amount of data copied to destination buffer.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub HID_SetReport: ::core::option::Option<
        unsafe extern "C" fn(
            hHid: USBD_HANDLE_T,
            pSetup: *mut USB_SETUP_PACKET,
            pBuffer: *mut *mut u8,
            length: u16,
        ) -> ErrorCode_t,
    >,
    #[doc = "  Optional callback function to handle HID_GetPhysDesc request.\n\n  The application software could provide this callback HID_GetPhysDesc handler to\n  handle get physical descriptor requests sent by the host. When host requests\n  Physical Descriptor set 0, application should return a special descriptor\n  identifying the number of descriptor sets and their sizes. A Get_Descriptor\n  request with the Physical Index equal to 1 should return the first Physical\n  Descriptor set. A device could possibly have alternate uses for its items.\n  These can be enumerated by issuing subsequent Get_Descriptor requests while\n  incrementing the Descriptor Index. A device should return the last descriptor\n  set to requests with an index greater than the last number defined in the HID\n  descriptor.\n  \\note Applications which don't have physical descriptor should set this data member\n  to zero before calling the USBD_HID_API::Init().\n  \\n\n\n  \\param[in] hHid Handle to HID function driver.\n  \\param[in] pSetup Pointer to setup packet received from host.\n  \\param[in] pBuf Pointer to a pointer of data buffer containing physical descriptor\n                   data. If the physical descriptor is in USB accessible memory area\n                   application could just update the pointer or else it should copy\n                   the descriptor to the address pointed by this pointer.\n  \\param[in] length  Amount of data copied to destination buffer or descriptor length.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub HID_GetPhysDesc: ::core::option::Option<
        unsafe extern "C" fn(
            hHid: USBD_HANDLE_T,
            pSetup: *mut USB_SETUP_PACKET,
            pBuf: *mut *mut u8,
            length: *mut u16,
        ) -> ErrorCode_t,
    >,
    #[doc = "  Optional callback function to handle HID_REQUEST_SET_IDLE request.\n\n  The application software could provide this callback to handle HID_REQUEST_SET_IDLE\n  requests sent by the host. This callback is provided to applications to adjust\n  timers associated with various reports, which are sent to host over interrupt\n  endpoint. The setup packet data (\\em pSetup) is passed to the callback so that\n  application can extract the report ID, report type and other information need\n  to modify the report's idle time.\n  \\note Applications which don't send reports on Interrupt endpoint or don't\n  have idle time between reports should set this data member to zero before\n  calling the USBD_HID_API::Init().\n  \\n\n\n  \\param[in] hHid Handle to HID function driver.\n  \\param[in] pSetup Pointer to setup packet received from host.\n  \\param[in] idleTime  Idle time to be set for the specified report.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub HID_SetIdle: ::core::option::Option<
        unsafe extern "C" fn(
            hHid: USBD_HANDLE_T,
            pSetup: *mut USB_SETUP_PACKET,
            idleTime: u8,
        ) -> ErrorCode_t,
    >,
    #[doc = "  Optional callback function to handle HID_REQUEST_SET_PROTOCOL request.\n\n  The application software could provide this callback to handle HID_REQUEST_SET_PROTOCOL\n  requests sent by the host. This callback is provided to applications to adjust\n  modes of their code between boot mode and report mode.\n  \\note Applications which don't support protocol modes should set this data member\n  to zero before calling the USBD_HID_API::Init().\n  \\n\n\n  \\param[in] hHid Handle to HID function driver.\n  \\param[in] pSetup Pointer to setup packet received from host.\n  \\param[in] protocol  Protocol mode.\n                       0 = Boot Protocol\n                       1 = Report Protocol\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub HID_SetProtocol: ::core::option::Option<
        unsafe extern "C" fn(
            hHid: USBD_HANDLE_T,
            pSetup: *mut USB_SETUP_PACKET,
            protocol: u8,
        ) -> ErrorCode_t,
    >,
    #[doc = "  Optional Interrupt IN endpoint event handler.\n\n  The application software could provide Interrupt IN endpoint event handler.\n  Application which send reports to host on interrupt endpoint should provide\n  an endpoint event handler through this data member. This data member is\n  ignored if the interface descriptor \\em intf_desc doesn't have any IN interrupt\n  endpoint descriptor associated.\n  \\n\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] data Handle to HID function driver.\n  \\param[in] event  Type of endpoint event. See \\ref USBD_EVENT_T for more details.\n  \\return The call back should return \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub HID_EpIn_Hdlr: ::core::option::Option<
        unsafe extern "C" fn(
            hUsb: USBD_HANDLE_T,
            data: *mut ::core::ffi::c_void,
            event: u32,
        ) -> ErrorCode_t,
    >,
    #[doc = "  Optional Interrupt OUT endpoint event handler.\n\n  The application software could provide Interrupt OUT endpoint event handler.\n  Application which receives reports from host on interrupt endpoint should provide\n  an endpoint event handler through this data member. This data member is\n  ignored if the interface descriptor \\em intf_desc doesn't have any OUT interrupt\n  endpoint descriptor associated.\n  \\n\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] data Handle to HID function driver.\n  \\param[in] event  Type of endpoint event. See \\ref USBD_EVENT_T for more details.\n  \\return The call back should return \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub HID_EpOut_Hdlr: ::core::option::Option<
        unsafe extern "C" fn(
            hUsb: USBD_HANDLE_T,
            data: *mut ::core::ffi::c_void,
            event: u32,
        ) -> ErrorCode_t,
    >,
    #[doc = "  Optional user override-able function to replace the default HID_GetReportDesc handler.\n\n  The application software could override the default HID_GetReportDesc handler with their\n  own by providing the handler function address as this data member of the parameter\n  structure. Application which like the default handler should set this data member\n  to zero before calling the USBD_HID_API::Init() and also provide report data array\n  \\em report_data field.\n  \\n\n  \\note\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] data Pointer to the data which will be passed when callback function is called by the stack.\n  \\param[in] event  Type of endpoint event. See \\ref USBD_EVENT_T for more details.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub HID_GetReportDesc: ::core::option::Option<
        unsafe extern "C" fn(
            hHid: USBD_HANDLE_T,
            pSetup: *mut USB_SETUP_PACKET,
            pBuf: *mut *mut u8,
            length: *mut u16,
        ) -> ErrorCode_t,
    >,
    #[doc = "  Optional user override-able function to replace the default HID class handler.\n\n  The application software could override the default EP0 class handler with their\n  own by providing the handler function address as this data member of the parameter\n  structure. Application which like the default handler should set this data member\n  to zero before calling the USBD_HID_API::Init().\n  \\n\n  \\note\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] data Pointer to the data which will be passed when callback function is called by the stack.\n  \\param[in] event  Type of endpoint event. See \\ref USBD_EVENT_T for more details.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub HID_Ep0_Hdlr: ::core::option::Option<
        unsafe extern "C" fn(
            hUsb: USBD_HANDLE_T,
            data: *mut ::core::ffi::c_void,
            event: u32,
        ) -> ErrorCode_t,
    >,
}
#[doc = " \\brief USB descriptors data structure.\n  \\ingroup USBD_HID\n\n  \\details  This module exposes functions which interact directly with USB device stack's core layer.\n  The application layer uses this component when it has to implement custom class function driver or\n  standard class function driver which is not part of the current USB device stack.\n  The functions exposed by this interface are to register class specific EP0 handlers and corresponding\n  utility functions to manipulate EP0 state machine of the stack. This interface also exposes\n  function to register custom endpoint interrupt handler.\n"]
pub type USBD_HID_INIT_PARAM_T = USBD_HID_INIT_PARAM;
#[doc = " \\brief HID class API functions structure.\n  \\ingroup USBD_HID\n\n  This structure contains pointers to all the function exposed by HID function driver module.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USBD_HID_API {
    #[doc = " \\fn uint32_t GetMemSize(USBD_HID_INIT_PARAM_T* param)\n  Function to determine the memory required by the HID function driver module.\n\n  This function is called by application layer before calling pUsbApi->hid->Init(), to allocate memory used\n  by HID function driver module. The application should allocate the memory which is accessible by USB\n  controller/DMA controller.\n  \\note Some memory areas are not accessible by all bus masters.\n\n  \\param[in] param Structure containing HID function driver module initialization parameters.\n  \\return Returns the required memory size in bytes."]
    pub GetMemSize:
        ::core::option::Option<unsafe extern "C" fn(param: *mut USBD_HID_INIT_PARAM_T) -> u32>,
    #[doc = " \\fn ErrorCode_t init(USBD_HANDLE_T hUsb, USBD_HID_INIT_PARAM_T* param)\n  Function to initialize HID function driver module.\n\n  This function is called by application layer to initialize HID function driver\n  module. On successful initialization the function returns a handle to HID\n  function driver module in passed param structure.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in, out] param Structure containing HID function driver module\n      initialization parameters.\n  \\return Returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success\n          \\retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte\n              aligned or smaller than required.\n          \\retval ERR_API_INVALID_PARAM2 Either HID_GetReport() or HID_SetReport()\n              callback are not defined.\n          \\retval ERR_USBD_BAD_DESC  HID_HID_DESCRIPTOR_TYPE is not defined\n              immediately after interface descriptor.\n          \\retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed.\n          \\retval ERR_USBD_BAD_EP_DESC  Wrong endpoint descriptor is passed."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(hUsb: USBD_HANDLE_T, param: *mut USBD_HID_INIT_PARAM_T) -> ErrorCode_t,
    >,
}
#[doc = " \\brief HID class API functions structure.\n  \\ingroup USBD_HID\n\n  This structure contains pointers to all the function exposed by HID function driver module.\n"]
pub type USBD_HID_API_T = USBD_HID_API;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CDC_HEADER_DESCRIPTOR {
    pub bFunctionLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bcdCDC: u16,
}
pub type CDC_HEADER_DESCRIPTOR = _CDC_HEADER_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CDC_CALL_MANAGEMENT_DESCRIPTOR {
    pub bFunctionLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bmCapabilities: u8,
    pub bDataInterface: u8,
}
pub type CDC_CALL_MANAGEMENT_DESCRIPTOR = _CDC_CALL_MANAGEMENT_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CDC_ABSTRACT_CONTROL_MANAGEMENT_DESCRIPTOR {
    pub bFunctionLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bmCapabilities: u8,
}
pub type CDC_ABSTRACT_CONTROL_MANAGEMENT_DESCRIPTOR = _CDC_ABSTRACT_CONTROL_MANAGEMENT_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CDC_UNION_DESCRIPTOR {
    pub bFunctionLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bMasterInterface: u8,
}
pub type CDC_UNION_DESCRIPTOR = _CDC_UNION_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CDC_UNION_1SLAVE_DESCRIPTOR {
    pub sUnion: CDC_UNION_DESCRIPTOR,
    pub bSlaveInterfaces: [u8; 1usize],
}
pub type CDC_UNION_1SLAVE_DESCRIPTOR = _CDC_UNION_1SLAVE_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CDC_LINE_CODING {
    pub dwDTERate: u32,
    pub bCharFormat: u8,
    pub bParityType: u8,
    pub bDataBits: u8,
}
pub type CDC_LINE_CODING = _CDC_LINE_CODING;
#[doc = " USB Default Control Pipe Setup Packet"]
pub type CDC_NOTIFICATION_HEADER = USB_SETUP_PACKET;
#[doc = " \\brief Communication Device Class function driver initialization parameter data structure.\n  \\ingroup USBD_CDC\n\n  \\details  This data structure is used to pass initialization parameters to the\n  Communication Device Class function driver's init function.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USBD_CDC_INIT_PARAM {
    #[doc = "< Base memory location from where the stack can allocate\ndata and buffers. \\note The memory address set in this field\nshould be accessible by USB DMA controller. Also this value\nshould be aligned on 4 byte boundary."]
    pub mem_base: u32,
    #[doc = "< The size of memory buffer which stack can use.\n\\note The \\em mem_size should be greater than the size\nreturned by USBD_CDC_API::GetMemSize() routine."]
    pub mem_size: u32,
    #[doc = " Pointer to the control interface descriptor within the descriptor\n array (\\em high_speed_desc) passed to Init() through \\ref USB_CORE_DESCS_T\n structure. The stack assumes both HS and FS use same BULK endpoints."]
    pub cif_intf_desc: *mut u8,
    #[doc = " Pointer to the data interface descriptor within the descriptor\n array (\\em high_speed_desc) passed to Init() through \\ref USB_CORE_DESCS_T\n structure. The stack assumes both HS and FS use same BULK endpoints."]
    pub dif_intf_desc: *mut u8,
    #[doc = "  Communication Interface Class specific get request call-back function.\n\n  This function is provided by the application software. This function gets called\n  when host sends CIC management element get requests.\n  \\note Applications implementing Abstract Control Model subclass can set this\n  param to NULL. As the default driver parses ACM requests and calls the\n  individual ACM call-back routines defined in this structure. For all other subclasses\n  this routine should be provided by the application.\n  \\n\n  The setup packet data (\\em pSetup) is passed to the call-back so that application\n  can extract the CIC request type and other associated data. By default the stack\n  will assign \\em pBuffer pointer to \\em EP0Buff allocated at init. The application\n  code can directly write data into this buffer as long as data is less than 64 byte.\n  If more data has to be sent then application code should update \\em pBuffer pointer\n  and length accordingly.\n\n\n  \\param[in] hCdc Handle to CDC function driver.\n  \\param[in] pSetup Pointer to setup packet received from host.\n  \\param[in, out] pBuffer  Pointer to a pointer of data buffer containing request data.\n                       Pointer-to-pointer is used to implement zero-copy buffers.\n                       See \\ref USBD_ZeroCopy for more details on zero-copy concept.\n  \\param[in, out] length  Amount of data to be sent back to host.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub CIC_GetRequest: ::core::option::Option<
        unsafe extern "C" fn(
            hHid: USBD_HANDLE_T,
            pSetup: *mut USB_SETUP_PACKET,
            pBuffer: *mut *mut u8,
            length: *mut u16,
        ) -> ErrorCode_t,
    >,
    #[doc = "  Communication Interface Class specific set request call-back function.\n\n  This function is provided by the application software. This function gets called\n  when host sends a CIC management element requests.\n  \\note Applications implementing Abstract Control Model subclass can set this\n  param to NULL. As the default driver parses ACM requests and calls the\n  individual ACM call-back routines defined in this structure. For all other subclasses\n  this routine should be provided by the application.\n  \\n\n  The setup packet data (\\em pSetup) is passed to the call-back so that application can\n  extract the CIC request type and other associated data. If a set request has data associated,\n  then this call-back is called twice.\n  -# First when setup request is received, at this time application code could update\n  \\em pBuffer pointer to point to the intended destination. The length param is set to 0\n  so that application code knows this is first time. By default the stack will\n  assign \\em pBuffer pointer to \\em EP0Buff allocated at init. Note, if data length is\n  greater than 64 bytes and application code doesn't update \\em pBuffer pointer the\n  stack will send STALL condition to host.\n  -# Second when the data is received from the host. This time the length param is set\n  with number of data bytes received.\n\n  \\param[in] hCdc Handle to CDC function driver.\n  \\param[in] pSetup Pointer to setup packet received from host.\n  \\param[in, out] pBuffer  Pointer to a pointer of data buffer containing request data.\n                       Pointer-to-pointer is used to implement zero-copy buffers.\n                       See \\ref USBD_ZeroCopy for more details on zero-copy concept.\n  \\param[in] length  Amount of data copied to destination buffer.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub CIC_SetRequest: ::core::option::Option<
        unsafe extern "C" fn(
            hCdc: USBD_HANDLE_T,
            pSetup: *mut USB_SETUP_PACKET,
            pBuffer: *mut *mut u8,
            length: u16,
        ) -> ErrorCode_t,
    >,
    #[doc = "  Communication Device Class specific BULK IN endpoint handler.\n\n  The application software should provide the BULK IN endpoint handler.\n  Applications should transfer data depending on the communication protocol type set in descriptors.\n  \\n\n  \\note\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] data Pointer to the data which will be passed when callback function is called by the stack.\n  \\param[in] event  Type of endpoint event. See \\ref USBD_EVENT_T for more details.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub CDC_BulkIN_Hdlr: ::core::option::Option<
        unsafe extern "C" fn(
            hUsb: USBD_HANDLE_T,
            data: *mut ::core::ffi::c_void,
            event: u32,
        ) -> ErrorCode_t,
    >,
    #[doc = "  Communication Device Class specific BULK OUT endpoint handler.\n\n  The application software should provide the BULK OUT endpoint handler.\n  Applications should transfer data depending on the communication protocol type set in descriptors.\n  \\n\n  \\note\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] data Pointer to the data which will be passed when callback function is called by the stack.\n  \\param[in] event  Type of endpoint event. See \\ref USBD_EVENT_T for more details.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub CDC_BulkOUT_Hdlr: ::core::option::Option<
        unsafe extern "C" fn(
            hUsb: USBD_HANDLE_T,
            data: *mut ::core::ffi::c_void,
            event: u32,
        ) -> ErrorCode_t,
    >,
    #[doc = "  Abstract control model(ACM) subclass specific SEND_ENCAPSULATED_COMMAND request call-back function.\n\n  This function is provided by the application software. This function gets called\n  when host sends a SEND_ENCAPSULATED_COMMAND set request.\n\n  \\param[in] hCdc Handle to CDC function driver.\n  \\param[in] buffer Pointer to the command buffer.\n  \\param[in] len  Length of the command buffer.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub SendEncpsCmd: ::core::option::Option<
        unsafe extern "C" fn(hCDC: USBD_HANDLE_T, buffer: *mut u8, len: u16) -> ErrorCode_t,
    >,
    #[doc = "  Abstract control model(ACM) subclass specific GET_ENCAPSULATED_RESPONSE request call-back function.\n\n  This function is provided by the application software. This function gets called\n  when host sends a GET_ENCAPSULATED_RESPONSE request.\n\n  \\param[in] hCdc Handle to CDC function driver.\n  \\param[in, out] buffer Pointer to a pointer of data buffer containing response data.\n                       Pointer-to-pointer is used to implement zero-copy buffers.\n                       See \\ref USBD_ZeroCopy for more details on zero-copy concept.\n  \\param[in, out] len  Amount of data to be sent back to host.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub GetEncpsResp: ::core::option::Option<
        unsafe extern "C" fn(
            hCDC: USBD_HANDLE_T,
            buffer: *mut *mut u8,
            len: *mut u16,
        ) -> ErrorCode_t,
    >,
    #[doc = "  Abstract control model(ACM) subclass specific SET_COMM_FEATURE request call-back function.\n\n  This function is provided by the application software. This function gets called\n  when host sends a SET_COMM_FEATURE set request.\n\n  \\param[in] hCdc Handle to CDC function driver.\n  \\param[in] feature Communication feature type. See usbcdc11.pdf, section 6.2.4, Table 47.\n  \\param[in] buffer Pointer to the settings buffer for the specified communication feature.\n  \\param[in] len  Length of the request buffer.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub SetCommFeature: ::core::option::Option<
        unsafe extern "C" fn(
            hCDC: USBD_HANDLE_T,
            feature: u16,
            buffer: *mut u8,
            len: u16,
        ) -> ErrorCode_t,
    >,
    #[doc = "  Abstract control model(ACM) subclass specific GET_COMM_FEATURE request call-back function.\n\n  This function is provided by the application software. This function gets called\n  when host sends a GET_ENCAPSULATED_RESPONSE request.\n\n  \\param[in] hCdc Handle to CDC function driver.\n  \\param[in] feature Communication feature type. See usbcdc11.pdf, section 6.2.4, Table 47.\n  \\param[in, out] buffer Pointer to a pointer of data buffer containing current settings\n                         for the communication feature.\n                       Pointer-to-pointer is used to implement zero-copy buffers.\n  \\param[in, out] len  Amount of data to be sent back to host.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub GetCommFeature: ::core::option::Option<
        unsafe extern "C" fn(
            hCDC: USBD_HANDLE_T,
            feature: u16,
            pBuffer: *mut *mut u8,
            len: *mut u16,
        ) -> ErrorCode_t,
    >,
    #[doc = "  Abstract control model(ACM) subclass specific CLEAR_COMM_FEATURE request call-back function.\n\n  This function is provided by the application software. This function gets called\n  when host sends a CLEAR_COMM_FEATURE request. In the call-back the application\n  should Clears the settings for a particular communication feature.\n\n  \\param[in] hCdc Handle to CDC function driver.\n  \\param[in] feature Communication feature type. See usbcdc11.pdf, section 6.2.4, Table 47.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub ClrCommFeature: ::core::option::Option<
        unsafe extern "C" fn(hCDC: USBD_HANDLE_T, feature: u16) -> ErrorCode_t,
    >,
    #[doc = "  Abstract control model(ACM) subclass specific SET_CONTROL_LINE_STATE request call-back function.\n\n  This function is provided by the application software. This function gets called\n  when host sends a SET_CONTROL_LINE_STATE request. RS-232 signal used to tell the DCE\n  device the DTE device is now present\n\n  \\param[in] hCdc Handle to CDC function driver.\n  \\param[in] state The state value uses bitmap values defined in usbcdc11.pdf,\n        section 6.2.14, Table 51.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub SetCtrlLineState: ::core::option::Option<
        unsafe extern "C" fn(hCDC: USBD_HANDLE_T, state: u16) -> ErrorCode_t,
    >,
    #[doc = "  Abstract control model(ACM) subclass specific SEND_BREAK request call-back function.\n\n  This function is provided by the application software. This function gets called\n  when host sends a SEND_BREAK request.\n\n  \\param[in] hCdc Handle to CDC function driver.\n  \\param[in] mstime Duration of Break signal in milliseconds. If mstime is FFFFh, then\n        the application should send break until another SendBreak request is received\n        with the wValue of 0000h.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub SendBreak: ::core::option::Option<
        unsafe extern "C" fn(hCDC: USBD_HANDLE_T, mstime: u16) -> ErrorCode_t,
    >,
    #[doc = "  Abstract control model(ACM) subclass specific SET_LINE_CODING request call-back function.\n\n  This function is provided by the application software. This function gets called\n  when host sends a SET_LINE_CODING request. The application should configure the device\n  per DTE rate, stop-bits, parity, and number-of-character bits settings provided in\n  command buffer. See usbcdc11.pdf, section 6.2.13, table 50 for detail of the command buffer.\n\n  \\param[in] hCdc Handle to CDC function driver.\n  \\param[in] line_coding Pointer to the CDC_LINE_CODING command buffer.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub SetLineCode: ::core::option::Option<
        unsafe extern "C" fn(hCDC: USBD_HANDLE_T, line_coding: *mut CDC_LINE_CODING) -> ErrorCode_t,
    >,
    #[doc = "  Optional Communication Device Class specific INTERRUPT IN endpoint handler.\n\n  The application software should provide the INT IN endpoint handler.\n  Applications should transfer data depending on the communication protocol type set in descriptors.\n  \\n\n  \\note\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] data Pointer to the data which will be passed when callback function is called by the stack.\n  \\param[in] event  Type of endpoint event. See \\ref USBD_EVENT_T for more details.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub CDC_InterruptEP_Hdlr: ::core::option::Option<
        unsafe extern "C" fn(
            hUsb: USBD_HANDLE_T,
            data: *mut ::core::ffi::c_void,
            event: u32,
        ) -> ErrorCode_t,
    >,
    #[doc = "  Optional user override-able function to replace the default CDC class handler.\n\n  The application software could override the default EP0 class handler with their\n  own by providing the handler function address as this data member of the parameter\n  structure. Application which like the default handler should set this data member\n  to zero before calling the USBD_CDC_API::Init().\n  \\n\n  \\note\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in] data Pointer to the data which will be passed when callback function is called by the stack.\n  \\param[in] event  Type of endpoint event. See \\ref USBD_EVENT_T for more details.\n  \\return The call back should returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success.\n          \\retval ERR_USBD_UNHANDLED  Event is not handled hence pass the event to next in line.\n          \\retval ERR_USBD_xxx  For other error conditions.\n"]
    pub CDC_Ep0_Hdlr: ::core::option::Option<
        unsafe extern "C" fn(
            hUsb: USBD_HANDLE_T,
            data: *mut ::core::ffi::c_void,
            event: u32,
        ) -> ErrorCode_t,
    >,
}
#[doc = " \\brief Communication Device Class function driver initialization parameter data structure.\n  \\ingroup USBD_CDC\n\n  \\details  This data structure is used to pass initialization parameters to the\n  Communication Device Class function driver's init function.\n"]
pub type USBD_CDC_INIT_PARAM_T = USBD_CDC_INIT_PARAM;
#[doc = " \\brief CDC class API functions structure.\n  \\ingroup USBD_CDC\n\n  This module exposes functions which interact directly with USB device controller hardware.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USBD_CDC_API {
    #[doc = " \\fn uint32_t GetMemSize(USBD_CDC_INIT_PARAM_T* param)\n  Function to determine the memory required by the CDC function driver module.\n\n  This function is called by application layer before calling pUsbApi->CDC->Init(), to allocate memory used\n  by CDC function driver module. The application should allocate the memory which is accessible by USB\n  controller/DMA controller.\n  \\note Some memory areas are not accessible by all bus masters.\n\n  \\param[in] param Structure containing CDC function driver module initialization parameters.\n  \\return Returns the required memory size in bytes."]
    pub GetMemSize:
        ::core::option::Option<unsafe extern "C" fn(param: *mut USBD_CDC_INIT_PARAM_T) -> u32>,
    #[doc = " \\fn ErrorCode_t init(USBD_HANDLE_T hUsb, USBD_CDC_INIT_PARAM_T* param)\n  Function to initialize CDC function driver module.\n\n  This function is called by application layer to initialize CDC function driver module.\n\n  \\param[in] hUsb Handle to the USB device stack.\n  \\param[in, out] param Structure containing CDC function driver module initialization parameters.\n  \\return Returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success\n          \\retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte\n              aligned or smaller than required.\n          \\retval ERR_API_INVALID_PARAM2 Either CDC_Write() or CDC_Read() or\n              CDC_Verify() callbacks are not defined.\n          \\retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed.\n          \\retval ERR_USBD_BAD_EP_DESC  Wrong endpoint descriptor is passed."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            hUsb: USBD_HANDLE_T,
            param: *mut USBD_CDC_INIT_PARAM_T,
            phCDC: *mut USBD_HANDLE_T,
        ) -> ErrorCode_t,
    >,
    #[doc = " \\fn ErrorCode_t SendNotification(USBD_HANDLE_T hCdc, uint8_t bNotification, uint16_t data)\n  Function to send CDC class notifications to host.\n\n  This function is called by application layer to send CDC class notifications to host.\n  See usbcdc11.pdf, section 6.3, Table 67 for various notification types the CDC device can send.\n  \\note The current version of the driver only supports following notifications allowed by ACM subclass:\n  CDC_NOTIFICATION_NETWORK_CONNECTION, CDC_RESPONSE_AVAILABLE, CDC_NOTIFICATION_SERIAL_STATE.\n  \\n\n  For all other notifications application should construct the notification buffer appropriately\n  and call hw->USB_WriteEP() for interrupt endpoint associated with the interface.\n\n  \\param[in] hCdc Handle to CDC function driver.\n  \\param[in] bNotification Notification type allowed by ACM subclass. Should be CDC_NOTIFICATION_NETWORK_CONNECTION,\n        CDC_RESPONSE_AVAILABLE or CDC_NOTIFICATION_SERIAL_STATE. For all other types ERR_API_INVALID_PARAM2\n        is returned. See usbcdc11.pdf, section 3.6.2.1, table 5.\n  \\param[in] data Data associated with notification.\n        \\n For CDC_NOTIFICATION_NETWORK_CONNECTION a non-zero data value is interpreted as connected state.\n        \\n For CDC_RESPONSE_AVAILABLE this parameter is ignored.\n        \\n For CDC_NOTIFICATION_SERIAL_STATE the data should use bitmap values defined in usbcdc11.pdf,\n        section 6.3.5, Table 69.\n  \\return Returns \\ref ErrorCode_t type to indicate success or error condition.\n          \\retval LPC_OK On success\n          \\retval ERR_API_INVALID_PARAM2  If unsupported notification type is passed.\n"]
    pub SendNotification: ::core::option::Option<
        unsafe extern "C" fn(hCdc: USBD_HANDLE_T, bNotification: u8, data: u16) -> ErrorCode_t,
    >,
}
#[doc = " \\brief CDC class API functions structure.\n  \\ingroup USBD_CDC\n\n  This module exposes functions which interact directly with USB device controller hardware.\n"]
pub type USBD_CDC_API_T = USBD_CDC_API;
#[doc = " \\brief Main USBD API functions structure.\n  \\ingroup Group_USBD\n\n  This structure contains pointer to various USB Device stack's sub-module\n  function tables. This structure is used as main entry point to access\n  various methods (grouped in sub-modules) exposed by ROM based USB device\n  stack.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USBD_API {
    #[doc = "< Pointer to function table which exposes functions\nwhich interact directly with USB device stack's core\nlayer."]
    pub hw: *const USBD_HW_API_T,
    #[doc = "< Pointer to function table which exposes functions\nwhich interact directly with USB device controller\nhardware."]
    pub core: *const USBD_CORE_API_T,
    #[doc = "< Pointer to function table which exposes functions\nprovided by MSC function driver module."]
    pub msc: *const USBD_MSC_API_T,
    #[doc = "< Pointer to function table which exposes functions\nprovided by DFU function driver module."]
    pub dfu: *const USBD_DFU_API_T,
    #[doc = "< Pointer to function table which exposes functions\nprovided by HID function driver module."]
    pub hid: *const USBD_HID_API_T,
    #[doc = "< Pointer to function table which exposes functions\nprovided by CDC-ACM function driver module."]
    pub cdc: *const USBD_CDC_API_T,
    #[doc = "< Reserved for future function driver module."]
    pub reserved6: *const u32,
    #[doc = "< Version identifier of USB ROM stack. The version is\ndefined as 0x0CHDMhCC where each nibble represents version\nnumber of the corresponding component.\nCC -  7:0  - 8bit core version number\nh - 11:8  - 4bit hardware interface version number\nM - 15:12 - 4bit MSC class module version number\nD - 19:16 - 4bit DFU class module version number\nH - 23:20 - 4bit HID class module version number\nC - 27:24 - 4bit CDC class module version number\nH - 31:28 - 4bit reserved"]
    pub version: u32,
}
#[doc = " \\brief Main USBD API functions structure.\n  \\ingroup Group_USBD\n\n  This structure contains pointer to various USB Device stack's sub-module\n  function tables. This structure is used as main entry point to access\n  various methods (grouped in sub-modules) exposed by ROM based USB device\n  stack.\n"]
pub type USBD_API_T = USBD_API;
extern "C" {
    pub static mut g_pUsbApi: *const USBD_API_T;
}
